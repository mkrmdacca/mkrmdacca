-- gh 5674299814,5674297809
_G.HideCharacter = true
_G.FlingEnabled = false
_G.TransparentRig = true
_G.ToolFling = false -- false = holding, true = fling
_G.AntiFling = true
_G.HatCollide = false
_G.CustomHats = true -- Enable or disable custom rig feature (basically old oxide when false)
_G.CH = {
    Head = {
        Name = "YourHatName",
        TextureId = "TextureIDHere",
        Orientation = CFrame.Angles(0, 0, 0)
    },
    Torso = {
        Name= "",
        TextureId = "",
        Orientation= CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
    },
    LeftArm = {
        Name= "Accessory (LArmNoob)",
        TextureId = "135650240593878", 
        Orientation= CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
    },

    RightArm = {
        Name= "Accessory (RArmNoob)",
        TextureId = "135650240593878", 
        Orientation= CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90))
    },

    LeftLeg = {
        Name= "MeshPartAccessory",
        TextureId = "5673921472", 
        Orientation= CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
    },

    RightLeg = {
        Name= "MeshPartAccessory",
        TextureId = "5673921282", 
        Orientation= CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90))
    }
}

if _G.Scale == nil then
_G.Scale = 1
end
if _G.CH.Head == nil then 
_G.CH.Head = {}
end
if _G.CH.Head.Name == nil then 
_G.CH.Head.Name = "wtfgangimgonnakms!"
end
_G.ClickFling = true
_G.TeleportCharacter = true
--[[ 
Oxide V3.6
Anything below should NOT be changed
]]
local str = game:GetService("SharedTableRegistry")
local gentgenv
if not getgenv then 
	getgenv = function()
		return _G
	end
end
local connect
local velocity
local flingpos = game:GetService("Players").LocalPlayer:GetMouse().Hit
local flingpart = game:GetService("Players").LocalPlayer:GetMouse().Target
local flingplr = nil
local sineee=os.clock()
local sine=os.clock()
local plr =game:GetService("Players").LocalPlayer
local lp = plr
local cf 
local lastcf = workspace.CurrentCamera.CFrame
local oldh = workspace.FallenPartsDestroyHeight
local tools = {}
local faketools = {}
local stopped = false
local char
local moveloop
local respawnloop
_G.Stopped = false
_G.SBV4R = false
_G.R6Mode = false
_G.MiztCompat = true
_G.Fling = false
game:GetService("StarterGui"):SetCore("SendNotification", {
	Title = "Oxide Reanimation V3.6";
	Duration = 20;
	Text = "This script was made by Hemi"
})
local function cfAdd(a,b) return a+b end
pcall(function()
task.spawn(function()
game:GetService("CoreGui"):WaitForChild("TopBarApp"):WaitForChild("FullScreenFrame"):WaitForChild("HurtOverlay"):Destroy()
end)
end)
local Hat = {
    Rename = function(HatID, NAME, oname)
        pcall(function()
            if oname == nil then oname = "Hat" end
            local character = game:GetService("Players").LocalPlayer.Character
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            
            for i, v in pairs(character:GetChildren()) do
                if v:IsA("Accessory") then
                    local isR15 = humanoid.RigType == Enum.HumanoidRigType.R15
                    local textureMatch = false
                    
                    -- Check for texture match based on rig type
                    if isR15 then
                        -- For R15: Check TextureID directly on Handle
                        textureMatch = tostring(v.Handle.TextureID) == tostring(HatID)
                    else
                        -- For R6: Check SpecialMesh TextureId
                        local mesh = v.Handle:FindFirstChildWhichIsA("SpecialMesh")
                        if mesh then
                            textureMatch = tostring(mesh.TextureId) == tostring(HatID)
                        end
                    end

                    if textureMatch then
                        if oname == "Hat" then
                            v.Name = NAME
                        elseif oname == "LARM" then
                            v.Name = "fooblet"
                        elseif oname == "RARM" then
                            v.Name = "gooblet"
                        else
                            v.Name = NAME
                        end
                    end
                end
            end
        end)
    end,
    
    Rename2 = function(HatID, NAME, rname, oname)
        pcall(function()
            if oname == nil then oname = "Hat" end
            local character = game:GetService("Players").LocalPlayer.Character
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            
            for i, v in pairs(character:GetChildren()) do
                if v:IsA("Accessory") and v.Name == rname then
                    local isR15 = humanoid.RigType == Enum.HumanoidRigType.R15
                    local textureMatch = false
                    
                    if isR15 then
                        textureMatch = tostring(v.Handle.TextureID) == tostring(HatID)
                    else
                        local mesh = v.Handle:FindFirstChildWhichIsA("SpecialMesh")
                        if mesh then
                            textureMatch = tostring(mesh.TextureId) == tostring(HatID)
                        end
                    end

                    if textureMatch then
                        if oname == "Hat" then
                            v.Name = NAME
                        elseif oname == "LARM" then
                            v.Name = "fooblet"
                        elseif oname == "RARM" then
                            v.Name = "gooblet"
                        else
                            v.Name = NAME
                        end
                    end
                end
            end
        end)
    end
}
local function redo()
	local gay = true -- dont edit >:(
	hmode = nil
	if gay == true then
		hmode = "norm" 
	else
		hmode = "alsoo3" -- hate this guy
	end
	Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Nitro-GT/OxideReanim/main/library"))()
	local HatMode=hmode
	if HatMode=="alsoo3" then
		local HATDUPES = Library.MakeTableOfHats("Mesh",{Mesh_Id=4315410540})
		HATDUPES[1].Name = "DemonGodSword"
		HATDUPES[2].Name = "RainbowGodSword"
		HATDUPES[3].Name = "ToxicLordSword"
		HATDUPES[4].Name = "DemonLordSword"
		if Library.FindHat("ShadowBladeMasterAccessory") then
			Library.FindHat("ShadowBladeMasterAccessory").Name="VoidLordSword"
		end
		if Library.FindHat("BladeMasterAccessory") then
			Library.FindHat("BladeMasterAccessory").Name="AuroraSword"
		end
	else
	end
	--game:GetService("Workspace")["Error_30363"].EyesOfTheEverWorld.Name = "Puffer Vest"
	loadstring(game:HttpGet("https://raw.githubusercontent.com/Nitro-GT/OxideReanim/main/stuff"))()
	local c = game:GetService("Players").LocalPlayer.Character
	_G.OxideRealChar = c
	local nria = false 
	local nlia = false 
	if c:FindFirstChild("Accessory (NoobRightArm)") then 
		nria = true 
	end 
	if c:FindFirstChild("Accessory (NoobLeftArm)") then 
		nlia = true 
	end 
	if _G.CustomHats == false then
		pcall(function()
			Hat.Rename("rbxassetid://125975972015302", "Tor")
			Hat.Rename("rbxassetid://135650240593878","","LARM")
			Hat.Rename("rbxassetid://135650240593878","","RARM")
		end)
		pcall(function()
			Hat.Rename("rbxassetid://70661572547971", "Tor")
			Hat.Rename("rbxassetid://136752500636691","","LARM")
			Hat.Rename("rbxassetid://136752500636691","","RARM")
		end)
        pcall(function()
            c["Accessory (RLeg)"].Name = "Accessory (rightleg)"
          end)
          pcall(function()
            c["Accessory (LLegNoob)"].Name = "Accessory (LLeg)"
          end)
          pcall(function()
            c["Accessory (RLegNoob)"].Name = "Accessory (rightleg)"
          end)
          pcall(function()
            c["Accessory (LArm)"].Name = "gooblet"
        end)
        pcall(function()
            c["Accessory (RArm)"].Name = "fooblet"
        end)
		pcall(function()
            c["RARM"].Name = "fooblet"
        end)
		pcall(function()
			Hat.Rename("rbxassetid://17374768001","","LARM")
			Hat.Rename("rbxassetid://17374768001","","RARM")
			Hat.Rename("rbxassetid://14251599953", "Tor")
		end)
		pcall(function()
			Hat.Rename("rbxassetid://18640914168","","LARM")
			Hat.Rename("rbxassetid://18640914168","","RARM")
		end)
		pcall(function()
			Hat.Rename("rbxassetid://14255544465","","LARM")
			Hat.Rename("rbxassetid://14255544465","","RARM")
		end)
		pcall(function()
			Hat.Rename("rbxassetid://13415110780", "Tor")
		end)
		pcall(function()
			Hat.Rename("rbxassetid://18640899481", "Tor")
		end)
		pcall(function()
			Hat.Rename("rbxassetid://14255543546","","LARM")
			Hat.Rename("rbxassetid://14255543546","","RARM")
		end)
		pcall(function()
			Hat.Rename("rbxassetid://14768664565", "Tor")
			Hat.Rename("rbxassetid://14768683674","","LARM")
			Hat.Rename("rbxassetid://14768683674","","RARM")
		end)

	else
		pcall(function()
			Hat.Rename2("rbxassetid://".._G.CH.Torso.TextureId, "Tor",_G.CH.Torso.Name)
			Hat.Rename2("rbxassetid://".._G.CH.LeftArm.TextureId,"",_G.CH.LeftArm.Name,"LARM")
			Hat.Rename2("rbxassetid://".._G.CH.RightArm.TextureId,"",_G.CH.RightArm.Name,"RARM")
			Hat.Rename2("rbxassetid://".._G.CH.LeftLeg.TextureId,"Accessory (LLeg)",_G.CH.LeftLeg.Name)
			Hat.Rename2("rbxassetid://".._G.CH.RightLeg.TextureId,"Accessory (rightleg)",_G.CH.RightLeg.Name)	
			Hat.Rename2("http://www.roblox.com/asset/?id=".._G.CH.Torso.TextureId, "Tor",_G.CH.Torso.Name)
			Hat.Rename2("http://www.roblox.com/asset/?id=".._G.CH.LeftArm.TextureId,"",_G.CH.LeftArm.Name,"LARM")
			Hat.Rename2("http://www.roblox.com/asset/?id=".._G.CH.RightArm.TextureId,"",_G.CH.RightArm.Name,"RARM")
			Hat.Rename2("http://www.roblox.com/asset/?id=".._G.CH.LeftLeg.TextureId,"Accessory (LLeg)",_G.CH.LeftLeg.Name)
			Hat.Rename2("http://www.roblox.com/asset/?id=".._G.CH.RightLeg.TextureId,"Accessory (rightleg)",_G.CH.RightLeg.Name)	
		end)
	end
	pcall(function()
		c.gooblet.Name = "fooblet"
	end)
	pcall(function()
		c.gooblet.Name = "fooblet"
	end)
	pcall(function()
		c["Accessory (LARM)"].Name = "gooblet"
	end)
	pcall(function()
		c["Accessory (RARM)"].Name = "RARM"
	end)
	pcall(function()
		if not c:FindFirstChild("Accessory (rightleg)") then
			c.gooblet.Name = "Accessory (rightleg)"
		end
	end)
	pcall(function()
		if not c:FindFirstChild("Accessory (LLeg)") then
			c.gooblet.Name = "Accessory (LLeg)"
		end
	end)
	pcall(function()
		c.fooblet.Name = "gooblet"
	end)
	pcall(function()
		if not c:FindFirstChild("Tor") then 
			c.ExtraNoobTorso.Name = "Tor"
		end
	end)
	pcall(function()
		c.SHADES.Handle.AccessoryWeld.C1 = CFrame.new(0, 0.025, -0.6, 1, 0, 0, 0, 1, 0, 0, 0, 1)
	end)
	pcall(function()
		c["Accessory (LARM)"].Name = "LARM"
	end)
	pcall(function()
		c["Accessory (RARM)"].Name = "RARM"
	end)
    pcall(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/Nitro-GT/OxideReanim/main/renameclones3"))()
    end)
	if _G.EnableNetLib == true then
		loadstring(game:HttpGet("https://raw.githubusercontent.com/TypicallyAUser/random-stuff/main/4eyesnetlib.lua"))()
		Network.CharacterRelative = false
		coroutine.resume(Network["PartOwnership"]["Enable"])
	end
	Connection = workspace.DescendantAdded:Connect(function(c)
		if c.Name == "Animate" then
			c.Disabled=false        
		end
	end)
	repeat wait() until game:GetService("Players").LocalPlayer.Character
	Char = game:GetService("Players").LocalPlayer.Character
	Died = game:GetService("Players").LocalPlayer.Character:WaitForChild("Humanoid").Died:Connect(function()
		Connection:Disconnect()
		Died:Disconnect()
	end)
	function waitForChild(parent, childName)
		local child = parent:findFirstChild(childName)
		if child then return child end
		while true do
			child = parent.ChildAdded:wait()
			if child.Name==childName then return child end
		end
	end
	if not workspace:FindFirstChild("non") then
		char = game:GetObjects("rbxassetid://140589790135981")[1]
	else
		char = workspace.non
	end
	_G.OxideFakeChar = char 
	getgenv().OxideFakeChar = char
	getgenv().OxideRealChar = c
	if c:FindFirstChildOfClass("CharacterMesh") then 
		c:FindFirstChildOfClass("CharacterMesh"):Clone().Parent = char 
	end
	if _G.MiztCompat == false then
		char.Name = c.Name.." (Dummy)"
	else
		char.Name = "non"
	end
	zz = Instance.new("Highlight",char)
	zz.FillTransparency = 1
	zz.DepthMode = Enum.HighlightDepthMode.Occluded
	zz.Enabled = false
	local qqz = Instance.new("Shirt",char)
	qqz.ShirtTemplate = "rbxassetid://0"
	if not workspace:FindFirstChild("non") then
		char:SetPrimaryPartCFrame(c.HumanoidRootPart.CFrame *CFrame.new(0,0,2))
	end
	c["Body Colors"]:Clone().Parent = char
	game:GetService("Players").LocalPlayer.Character.PrimaryPart = c.Head
	char.HumanoidRootPart.Anchored = false
	for i,v in pairs(c:GetChildren()) do
		if v:IsA("Accessory") and v.Name == "Pants" then
			v:Destroy()
		end
	end
	char.Parent = workspace
	c.Parent = char
	_G.Flinging = false
	local swordbigvel = false
	velocity = game:GetService("RunService").Heartbeat:Connect(function(set)
		for i,v in pairs(c:GetChildren()) do
			if v:IsA("Accessory")  then
				v.Handle.AssemblyLinearVelocity = Vector3.new(char.Torso.AssemblyLinearVelocity.X*25, 25.01, char.Torso.AssemblyLinearVelocity*25)
			end
		end
	end)
	local function force(part,force)
		local bodyforce = Instance.new("BodyForce", part)
		bodyforce.Force = force
	end
	for i,v in pairs(c:GetChildren()) do
		if v:IsA("Part") or v:IsA("MeshPart") then
			force(v,Vector3.new(80,80,80))
		end
	end
	speaker = game:GetService("Players").LocalPlayer
	for _, child in pairs(c:GetChildren()) do
		if child:IsA("Part") then
			child.Anchored = true
		elseif child:IsA("Accessory") then
			child.Handle.Anchored = true
		end
	end
	for _, v in pairs(char:GetChildren()) do
		if v:IsA("Part") then
			v.CollisionGroup = c.Head.CollisionGroup
		end
	end	
	if c.Humanoid.RigType == Enum.HumanoidRigType.R6 then
		for _,v in pairs(c:GetChildren()) do
			if v:IsA("Accessory")  and v.Name ~= "gooblet" and v.Name ~= "fooblet" and v.Name ~= "Accessory (RARM)" and v.Name ~= "Accessory (LARM)" and not string.find(v.Name,"Accessory (Noob") and v.Name ~= "Accessory (NoobLeftArm)"  and v.Name ~= "Accessory (NoobTorso)"  and v.Name ~= "Accessory (NoobRightArm)" and v.Name ~= "Accessory (rightleg)" and v.Name ~= "Accessory (LLeg)"  and v.Name ~= "Rarm" and v.Name ~= "funnihead"  and v.Name ~= "Larm" and v.Name ~= "RectangleFace" and v.Name ~= "Tor" and v.Name ~= "RectangleHead-2"  and v.Name ~= "BlueRobotArm" and v.Name ~= "GreyRobotArm"   and v.Name ~= "Tor" and v.Name ~= "PurpleRobotArm" and v.Name ~= "RobotArmTest"  and v.Name ~= "LARM" and v.Name ~= "RARM"  and v.Name ~="Unloaded head" and v:WaitForChild("Handle"):FindFirstChildOfClass("SpecialMesh").MeshId ~= "rbxassetid://11263221350"  then
				if not char:FindFirstChild(v.Name) then
					local a = v:Clone()
					a.Handle.AccessoryWeld.Part1 = char[a.Handle.AccessoryWeld.Part1.Name]
					Accessory = v
					a.Parent = char
					a.Handle.Anchored = false
					a.Handle.Transparency = 1
				end
			end
		end
	else
		for _,v in pairs(c:GetChildren()) do
			if v:IsA("Accessory")  and v.Name ~= "gooblet" and v.Name ~= "Pouch" and v.Name ~= "Scooper"   and v.Name ~= "fooblet"  and not string.find(v.Name,"Accessory (Noob") and v.Name ~= "Accessory (NoobLeftArm)"  and v.Name ~= "Accessory (NoobTorso)"  and v.Name ~= "Accessory (NoobRightArm)" and v.Name ~= "Rarm" and v.Name ~= "funnihead"  and v.Name ~= "Larm" and v.Name ~= "RectangleFace" and v.Name ~= "Tor" and v.Name ~= "RectangleHead-2"  and v.Name ~= "BlueRobotArm" and v.Name ~= "GreyRobotArm"   and v.Name ~= "Tor" and v.Name ~= "PurpleRobotArm" and v.Name ~= "RobotArmTest"  and v.Name ~= "LARM" and v.Name ~= "RARM"  and v.Name ~="Unloaded head" and v:WaitForChild("Handle").MeshId ~= "rbxassetid://11263221350"  then
				if not char:FindFirstChild(v.Name) then
					local a = v:Clone()
					a.Handle:BreakJoints()
					Accessory = v
					Handle = Accessory.Handle
					z = a
					a.Parent = char
					a.Handle.Anchored = false
					a.Handle.Transparency = 1
					a.Handle.Position = char.Head.Position
					a.Handle.Velocity = Vector3.new(0,0,0)
					a.Handle.Massless = true
					w = Instance.new("Weld",z.Handle)
					w.C0 = w.Parent:FindFirstChildOfClass("Attachment").CFrame
					w.Name = "AccessoryWeld"
					w.Part0 = z.Handle
					a  = w.Parent:FindFirstChildOfClass("Attachment")
					if string.find(a.Name,"Left") then
						if string.find(a.Name,"Shoulder") then
							w.Part1 = char["Left Arm"]
							w.C1 =  char["Left Arm"].LeftShoulderAttachment.CFrame
						end
					elseif string.find(a.Name,"Right") then
						if string.find(a.Name,"Shoulder") then
							w.Part1 = char["Right Arm"]
							w.C1 =  char["Right Arm"].RightShoulderAttachment.CFrame
						end
					elseif string.find(a.Name,"Left") then
						if string.find(a.Name,"Foot") then
							w.Part1 = char["Left Leg"]
							w.C1 =  char["Left Leg"].LeftFootAttachment.CFrame
						end
					elseif string.find(a.Name,"Right") then
						if string.find(a.Name,"Foot") then
							w.Part1 = char["Right Leg"]
							w.C1 =  char["Right Leg"].RightFootAttachment.CFrame
						end
					elseif string.find(a.Name,"Waist") then
						if string.find(a.Name,"Back") then
							w.Part1 = char["Torso"]
							w.C1 =  char["Torso"].WaistBackAttachment.CFrame
						end    
					elseif string.find(a.Name,"Body") then
						if string.find(a.Name,"Back") then
							w.Part1 = char["Torso"]
							w.C1 =  char["Torso"].BodyBackAttachment.CFrame
						elseif  string.find(a.Name,"Front") then
							w.Part1 = char["Torso"]
							w.C1 =  char["Torso"].BodyFrontAttachment.CFrame
						end    
					elseif string.find(a.Name,"Hat") then
						w.Part1 = char["Head"]
						w.C1 =  char["Head"].HatAttachment.CFrame 
					elseif string.find(a.Name,"FaceFront") then
						w.Part1 = char["Head"]
						w.C1 =  char["Head"].FaceFrontAttachment.CFrame 
					elseif string.find(a.Name,"FaceCenter") then
						w.Part1 = char["Head"]
						w.C1 =  char["Head"].FaceCenterAttachment.CFrame 
					elseif string.find(a.Name,"Neck") then
						w.Part1 = char["Torso"]
						w.C1 =  char["Torso"].NeckAttachment.CFrame 
					elseif string.find(a.Name,"Hair") then
						w.Part1 = char["Head"]
						w.C1 =  char["Head"].HairAttachment.CFrame 
					end
				end
			end
		end
	end
	for i,v in pairs(c:GetChildren()) do
		if v:IsA("Accessory") then
			force(v.Handle,Vector3.new(80,80,80))
		end
	end
	for _,v in pairs(c:GetChildren()) do
		if v:IsA("Accessory") and v.Name ~= "RectangleHead" and v.Name ~= "RectangleHead-1"  and v.Name ~= "RectangleHead-3"  and v.Name ~= "funnihead" and v.Name ~= "RectangleFace-1" and v.Name ~= "RectangleFace" and v.Name ~= "RectangleFace-2" and v.Name ~= "RectangleHead-2"     then
			v.Handle:BreakJoints()
		end
	end 
	for _,v in pairs(c:GetChildren()) do
		if v:IsA("Accessory") and v.Name == "RectangleHead" and v.Name =="Puffer Vest" and v.Name == "RectangleFace" and v.Name == "RectangleFace-2" and v.Name == "RectangleHead-2"     then
			v.Handle:BreakJoints()
		end
	end 
	for _, child in pairs(char:GetChildren()) do
		if child:IsA("BasePart") then
			child.Transparency = 1
		end
	end
	local ch = game:GetService("Players").LocalPlayer.Character
	function getRoot(char)
		local rootPart = char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Torso')
		return rootPart
	end
	local character = game:GetService("Players").LocalPlayer.Character
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid and humanoid.SeatPart then
		humanoid.Sit = false
		wait(0.1)
	end
	local hipHeight = humanoid and humanoid.HipHeight > 0 and (humanoid.HipHeight + 1)
	local rootPart = getRoot(character)
	local rootPartPosition = rootPart.Position
	game:GetService("Players").LocalPlayer.Character=char
	if _G.wackyhead == true then 
		wait(game:GetService("Players").RespawnTime + 0.5)  
	end
	--wait(game:GetService("Players").RespawnTime + 0.25)  
	rootPart.CFrame = CFrame.new(char.HumanoidRootPart.CFrame.X,char.HumanoidRootPart.CFrame.Y,char.HumanoidRootPart.CFrame.Z) + Vector3.new(0, hipHeight or 4, 0)
	if _G.ReanimatedAnimations == true then
		pcall(function()
			c.Animate.Disabled = true
			c.Animate.Disabled = false
			char.Animate:Destroy()
			c.Animate.Parent = char
			char.Animate.Disabled = true
			--char.Animate.Disabled = false
		end)
		c.Humanoid.Animator.Parent = char.Humanoid
		workspace.CurrentCamera.CameraSubject = char.Humanoid
	else 
		char.Animate:Destroy()
		c.Animate.Disabled = true
		c.Animate.Parent = char
		char.Animate.Disabled = true
		c.Humanoid.Animator.Parent = char.Humanoid
		workspace.CurrentCamera.CameraSubject = char.Humanoid
	end
	if c:FindFirstChild("Torso") then
		c.Torso["Right Hip"]:Destroy()
		c.Torso["Left Hip"]:Destroy()
		c.Torso["Right Shoulder"]:Destroy()
		c.Torso["Left Shoulder"]:Destroy()
	end
	if _G.wackyhead == true then 
		c.Torso.Neck:Destroy()
	end
	c.Humanoid:TakeDamage(c.Humanoid.MaxHealth*9e9)
	c:BreakJoints()
	if c:FindFirstChild("Torso") then
		--c.Torso.Neck:Destroy()
	else
		--c.Head.Neck:Destroy()
		c.Humanoid:TakeDamage(c.Humanoid.MaxHealth)
	end
	local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/TypicallyAUser/TypicalsConvertingLibrary/main/Main"))()
	speaker = game:GetService("Players").LocalPlayer
	Clip = false
	local function NoclipLoop()
		for _, child in pairs(c:GetChildren()) do
			if child:IsA("BasePart") then
				child.CanCollide = false
			end
		end
	end
	Noclipping = game:GetService('RunService').Stepped:Connect(NoclipLoop)
	local Char = game:GetService("Players").LocalPlayer.Character
	local Hum = Char:FindFirstChildOfClass("Humanoid") or Char:FindFirstChildOfClass("AnimationController")
	for i,v in next, Hum:GetPlayingAnimationTracks() do
		v:Stop()
	end
	if _G.Fling == true then
		local Held = false
		local Mouse = game:GetService("Players").LocalPlayer:GetMouse()
		Mouse.Button1Down:Connect(function()
			Held = true
		end)
		Mouse.Button1Up:Connect(function()
			Held = false
		end)
		c.HumanoidRootPart.Transparency = 0.7
		local BodyVelocity = Instance.new("BodyVelocity", c.HumanoidRootPart)
		BodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
		BodyVelocity.Velocity = Vector3.new(0, 0, 0)
		flinger = Instance.new("BodyAngularVelocity",c.HumanoidRootPart)
		flinger.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
		flinger.P = 1000000000000000000000000000
		flinger.AngularVelocity = Vector3.new(5000000000000000000,5000000000000000000,5000000000000000000)
		spawn(function()
			while task.wait() do
				pcall(function()
					if Held == true then
						_G.Flinging = true
						c.HumanoidRootPart.CFrame = Mouse.Hit
					else
						_G.Flinging = false
						c.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0,-10,0)
					end
				end)
			end
		end)
	end
	for _, child in pairs(c:GetChildren()) do
		if child:IsA("Part") then
			child.Anchored = true
		elseif child:IsA("Accessory") then
			child.Handle.Anchored = false
		end
	end
	local removinghealth = false
	local canactuallydo
	if _G.FasterLoad == true then
		canactuallydo = false
	else
		canactuallydo = true
	end
	for k,v in pairs(c:GetChildren()) do
		if v:IsA("Accessory") then
			--     v.Handle:FindFirstChild("Attachment"):Destroy() -- destroying basic welds
		end
	end
	-- workspace[game:GetService("Players").LocalPlayer.Name.." Protected Welds"]:Destroy()
	local function Align(Part1, Part0, Position, Angle)
		if _G.EnableNetLib == true then
			Network.RetainPart(Part1)
		end
		game:GetService("RunService").Heartbeat:Connect(function(set)
			Part1.CFrame = Part0.CFrame * Position * Angle
		end)
	end
	local function Align2(Part1, Part0, Position, Angle)
		game:GetService("RunService").Heartbeat:Connect(function(set)
			if removinghealth == false then
				Part1.CFrame = Part0.CFrame * Position * Angle
			end
		end)
	end
	local function Align3 (Part1, Part0, Position, Angle)
		game:GetService("RunService").Heartbeat:Connect(function(set)
			if _G.Fling == false then
				Part1.CFrame = Part0.CFrame * Position * Angle
			end
		end)
	end
	local sin = math.sin

	local antisleepMultiplier=Vector3.new(-.0025,-.005,-.0025)
	connect = game:GetService("RunService").Heartbeat:Connect(function(set)
		sine=os.clock
		local antisleep=sin(sine()*100)*antisleepMultiplier
		pcall(function()
			c["Tor"].Handle.CFrame = char["Torso"].CFrame *CFrame.new(0,0,0)   +antisleep
		end)
		pcall(function()
			if nlia == false then 
				c["gooblet"].Handle.CFrame = char["Left Arm"].CFrame * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))  +antisleep
			else 
				c["gooblet"].Handle.CFrame = char["Left Arm"].CFrame * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))  +antisleep
			end
		end)
		pcall(function()
			if nria == false then 
				c["fooblet"].Handle.CFrame = char["Right Arm"].CFrame * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))+antisleep
			else 
				c["fooblet"].Handle.CFrame = char["Right Arm"].CFrame * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))+antisleep
			end
		end)
		pcall(function()
			c["Accessory (rightleg)"].Handle.CFrame = char["Right Leg"].CFrame  * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))   +antisleep
		end)
		pcall(function()
			c["Accessory (LLeg)"].Handle.CFrame = char["Left Leg"].CFrame  * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))   +antisleep
		end)
		pcall(function()
			for _,v in pairs(c:GetChildren()) do
				if v:IsA("Accessory") and v.Name ~= "gooblet" and v.Name ~= "fooblet"   and v.Name ~= "BlueRobotArm" and v.Name ~= "GreyRobotArm"   and v.Name ~= "Tor" and v.Name ~= "PurpleRobotArm" and v.Name ~= "RobotArmTest"  and v.Name ~= "LARM" and v.Name ~= "RARM" and v.Name ~= "Accessory (rightleg)" and v.Name ~= "Accessory (LLeg)" then  
					v.Handle.CFrame = char[v.Name].Handle.CFrame +antisleep
					v.Handle.CanTouch = false
				end
			end
		end)       
		for _,v in pairs(c:GetChildren()) do
			if v:IsA("Accessory")   then
				v.Handle.CanCollide = false
			end
		end
		oldcf = workspace.CurrentCamera.CFrame
		settings().Physics.AllowSleep = false
	end)
	settings().Physics.AllowSleep = false
	wait()
	pcall(function()
		rootPart.CFrame = CFrame.new(char.HumanoidRootPart.CFrame.X,-300,char.HumanoidRootPart.CFrame.Z) + Vector3.new(0, hipHeight or 4, 0)
	end)
	pcall(function()
		for _, child in pairs(c:GetChildren()) do
			if child:IsA("Part") then
				child.Anchored = false
			elseif child:IsA("Accessory") then
				child.Handle.Anchored = false
			end
		end
	end)
	task.spawn(function()
		wait(game:GetService("Players").RespawnTime - .05)
		task.wait(.05)
		velocity:Disconnect() 
		connect:Disconnect()
	end)
end
local function redo2()
	wait(.001)
	local gay = true -- dont edit >:(
	hmode = nil
	if gay == true then
		hmode = "norm" 
	else
		hmode = "alsoo3" -- hate this guy
	end
	Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Nitro-GT/OxideReanim/main/library"))()
	local HatMode=hmode
	if HatMode=="alsoo3" then
		local HATDUPES = Library.MakeTableOfHats("Mesh",{Mesh_Id=4315410540})
		HATDUPES[1].Name = "DemonGodSword"
		HATDUPES[2].Name = "RainbowGodSword"
		HATDUPES[3].Name = "ToxicLordSword"
		HATDUPES[4].Name = "DemonLordSword"
		if Library.FindHat("ShadowBladeMasterAccessory") then
			Library.FindHat("ShadowBladeMasterAccessory").Name="VoidLordSword"
		end
		if Library.FindHat("BladeMasterAccessory") then
			Library.FindHat("BladeMasterAccessory").Name="AuroraSword"
		end
	else
	end
	local c = game:GetService("Players").LocalPlayer.Character
	--game:GetService("Workspace")["Error_30363"].EyesOfTheEverWorld.Name = "Puffer Vest"
	if _G.CustomHats == false then
		pcall(function()
			Hat.Rename("rbxassetid://17374768001","","LARM")
			Hat.Rename("rbxassetid://17374768001","","RARM")
			Hat.Rename("rbxassetid://14251599953", "Tor")
		end)
		pcall(function()
			Hat.Rename("rbxassetid://18640914168","","LARM")
			Hat.Rename("rbxassetid://18640914168","","RARM")
		end)
		pcall(function()
			Hat.Rename("rbxassetid://14255544465","","LARM")
			Hat.Rename("rbxassetid://14255544465","","RARM")
		end)
		pcall(function()
			Hat.Rename("rbxassetid://13415110780", "Tor")
		end)
		pcall(function()
			Hat.Rename("rbxassetid://18640899481", "Tor")
		end)
		pcall(function()
			Hat.Rename("rbxassetid://14255543546","","LARM")
			Hat.Rename("rbxassetid://14255543546","","RARM")
		end)
		pcall(function()
			Hat.Rename("rbxassetid://14768664565", "Tor")
			Hat.Rename("rbxassetid://14768683674","","LARM")
			Hat.Rename("rbxassetid://14768683674","","RARM")
		end)

		pcall(function()
			Hat.Rename("rbxassetid://125975972015302", "Tor")
			Hat.Rename("rbxassetid://135650240593878","","LARM")
			Hat.Rename("rbxassetid://135650240593878","","RARM")
		end)
        pcall(function()
            c["Accessory (RLeg)"].Name = "Accessory (rightleg)"
          end)
          pcall(function()
            c["Accessory (LLegNoob)"].Name = "Accessory (LLeg)"
          end)
          pcall(function()
            c["Accessory (RLegNoob)"].Name = "Accessory (rightleg)"
          end)
          pcall(function()
            c["Accessory (LArm)"].Name = "gooblet"
        end)
        pcall(function()
            c["Accessory (RArm)"].Name = "fooblet"
        end)
		pcall(function()
			Hat.Rename("rbxassetid://79186624401216","fooblet")
        end)
		pcall(function()
			Hat.Rename("rbxassetid://70661572547971", "Tor")
			Hat.Rename("rbxassetid://136752500636691","","LARM")
			Hat.Rename("rbxassetid://136752500636691","","RARM")
		end)
	else
		pcall(function()
			Hat.Rename2("rbxassetid://".._G.CH.Torso.TextureId, "Tor",_G.CH.Torso.Name)
			Hat.Rename2("rbxassetid://".._G.CH.LeftArm.TextureId,"",_G.CH.LeftArm.Name,"LARM")
			Hat.Rename2("rbxassetid://".._G.CH.RightArm.TextureId,"",_G.CH.RightArm.Name,"RARM")
			Hat.Rename2("rbxassetid://".._G.CH.LeftLeg.TextureId,"Accessory (LLeg)",_G.CH.LeftLeg.Name)
			Hat.Rename2("rbxassetid://".._G.CH.RightLeg.TextureId,"Accessory (rightleg)",_G.CH.RightLeg.Name)	
			Hat.Rename2("http://www.roblox.com/asset/?id=".._G.CH.Torso.TextureId, "Tor",_G.CH.Torso.Name)
			Hat.Rename2("http://www.roblox.com/asset/?id=".._G.CH.LeftArm.TextureId,"gooblet",_G.CH.LeftArm.Name)
			Hat.Rename2("http://www.roblox.com/asset/?id=".._G.CH.RightArm.TextureId,"fooblet",_G.CH.RightArm.Name)
			Hat.Rename2("http://www.roblox.com/asset/?id=".._G.CH.LeftLeg.TextureId,"Accessory (LLeg)",_G.CH.LeftLeg.Name)
			Hat.Rename2("http://www.roblox.com/asset/?id=".._G.CH.RightLeg.TextureId,"Accessory (rightleg)",_G.CH.RightLeg.Name)	
		end)
	end
	pcall(function()
		c.gooblet.Name = "fooblet"
	end)
	pcall(function()
		c.gooblet.Name = "fooblet"
	end)
	pcall(function()
		c["Accessory (LARM)"].Name = "gooblet"
	end)
	pcall(function()
		c["Accessory (RARM)"].Name = "RARM"
	end)
	pcall(function()
		c["RARM"].Name = "fooblet"
	end)
	pcall(function()
		if not c:FindFirstChild("Accessory (rightleg)") then
			c.gooblet.Name = "Accessory (rightleg)"
		end
	end)
	pcall(function()
		if not c:FindFirstChild("Accessory (LLeg)") then
			c.gooblet.Name = "Accessory (LLeg)"
		end
	end)
	pcall(function()
		c.fooblet.Name = "gooblet"
	end)
	pcall(function()
		if not c:FindFirstChild("Tor") then 
			c.ExtraNoobTorso.Name = "Tor"
		end
	end)
	local nria = false 
	local nlia = false 
	pcall(function()
		if c.Humanoid.RigType == Enum.HumanoidRigType.R6 then
			if c:FindFirstChild("fooblet").Handle:FindFirstChildOfClass("SpecialMesh").TextureId == "rbxassetid://18640914168" then 
				nria = true 
			end 
		elseif c.Humanoid.RigType == Enum.HumanoidRigType.R15 then
			if c:FindFirstChild("fooblet").Handle.TextureID == "rbxassetid://18640914168" then 
				nria = true 
			end 
		end 
	end)
	pcall(function()
		if c.Humanoid.RigType == Enum.HumanoidRigType.R6 then
			if c:FindFirstChild("gooblet").Handle:FindFirstChildOfClass("SpecialMesh").TextureId == "rbxassetid://18640914168" then 
				nlia = true 
			end 
		elseif c.Humanoid.RigType == Enum.HumanoidRigType.R15 then
			if c:FindFirstChild("gooblet").Handle.TextureID == "rbxassetid://18640914168" then 
				nlia = true 
			end 
		end 
	end)
pcall(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/Nitro-GT/OxideReanim/main/renameclones3"))()
    end)
	pcall(function()
		c["gooblet-1"].Name = "fooblet"
	end)
	local flingloop
	function waitForChild(parent, childName)
		local child = parent:findFirstChild(childName)
		if child then return child end
		while true do
			child = parent.ChildAdded:wait()
			if child.Name==childName then return child end
		end
	end
	if not workspace:FindFirstChild("non") then
		char =  workspace.Terrain.non
	else
		char = workspace.non
	end
	if c ~= char then
		_G.OxideRealChar = c
	else 
		_G.OxideRealChar = workspace[lp.Name]
	end
	getgenv().OxideRealChar = _G.OxideRealChar
	speaker = game:GetService("Players").LocalPlayer
	Clip = false
	local function NoclipLoop()
		for _, child in pairs(c:GetChildren()) do
			if child:IsA("BasePart") then
				child.CanCollide = false
			end
		end
	end
	for i,v in pairs(c:GetChildren()) do
		if v:IsA("Accessory") and v.Name == "Pants" then
			v:Destroy()
		end
	end

	char.Parent = workspace
	c.Parent = char
	_G.Flinging = false
	local swordbigvel = false
	function getRoot(char)
		local rootPart = char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Torso') 
		return rootPart
	end
	local character = game:GetService("Players").LocalPlayer.Character
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid and humanoid.SeatPart then
		humanoid.Sit = false
		wait(0.1)
	end
	local hipHeight = humanoid and humanoid.HipHeight > 0 and (humanoid.HipHeight + 1)
	local rootPart = getRoot(character)
	for i,v in pairs(c:GetDescendants()) do
		if v:IsA("BasePart") then
			v.AssemblyAngularVelocity = Vector3.new(0,0,0)
			v.AssemblyLinearVelocity = Vector3.new(0,0,0)
		end
	end
	speaker = game:GetService("Players").LocalPlayer
	for _, child in pairs(c:GetChildren()) do
		if child:IsA("Part") then
			child.Anchored = false
		elseif child:IsA("Accessory") then
			child.Handle.Anchored = true
		end
	end
	for _, v in pairs(char:GetChildren()) do
		if v:IsA("Part") then
			pcall(function()
				v.CollisionGroup = c.Head.CollisionGroup
			end)
		end
	end	
	if c.Humanoid.RigType == Enum.HumanoidRigType.R6 then
		for _,v in pairs(c:GetChildren()) do
			if v:IsA("Accessory")  and v.Name ~= "gooblet"  and v.Name ~= "Accessory (RARM)" and v.Name ~= "Accessory (LARM)" and v.Name ~= "fooblet" and v.Name ~= "Accessory (rightleg)"   and not string.find(v.Name,"Accessory (Noob") and v.Name ~= "Accessory (NoobLeftArm)"  and v.Name ~= "Accessory (NoobTorso)"  and v.Name ~= "Accessory (NoobRightArm)"  and v.Name ~= "Accessory (LLeg)" and v.Name ~= "Accessory (LARM)"  and v.Name ~= "Rarm" and v.Name ~= "funnihead"  and v.Name ~= "Larm" and v.Name ~= "RectangleFace" and v.Name ~= "BlueRobotArm" and v.Name ~= "GreyRobotArm"   and v.Name ~= "Tor" and v.Name ~= "PurpleRobotArm" and v.Name ~= "RobotArmTest"  and v.Name ~= "RectangleHead-2"  and v.Name ~= "Tor" and v.Name ~= "Accessory (LLeg)" and v.Name ~= "RARM"  and v.Name ~="Unloaded head" then
				if not char:FindFirstChild(v.Name) then
					local a = v:Clone()
					a.Handle.AccessoryWeld.Part1 = char[a.Handle.AccessoryWeld.Part1.Name]
					Accessory = v
					Handle = Accessory.Handle
					a.Parent = char
					a.Handle.Anchored = false
					a.Handle.Transparency = 1
				end
			end
		end
	else
		for _,v in pairs(c:GetChildren()) do
			if v:IsA("Accessory") and v.Name ~= "Pouch" and v.Name ~= "Scooper"    and v.Name ~= "gooblet" and v.Name ~= "fooblet" and v.Name ~= "Accessory (rightleg)"  and not string.find(v.Name,"Accessory (Noob") and v.Name ~= "Accessory (NoobLeftArm)"  and v.Name ~= "Accessory (NoobTorso)"  and v.Name ~= "Accessory (NoobRightArm)"and v.Name ~= "Accessory (LARM)"  and v.Name ~= "Rarm" and v.Name ~= "funnihead"  and v.Name ~= "Larm" and v.Name ~= "RectangleFace" and v.Name ~= "Tor" and v.Name ~= "RectangleHead-2"  and v.Name ~= "BlueRobotArm" and v.Name ~= "GreyRobotArm"   and v.Name ~= "Tor" and v.Name ~= "PurpleRobotArm" and v.Name ~= "RobotArmTest"  and v.Name ~= "Accessory (LLeg)" and v.Name ~= "RARM"  and v.Name ~="Unloaded head"  then
				if not char:FindFirstChild(v.Name) then
					local a = v:Clone()
					a.Handle:BreakJoints()
					Accessory = v
					Handle = Accessory.Handle
					z = a
					a.Parent = char
					a.Handle.Anchored = false
					a.Handle.Transparency = 1
					a.Handle.CFrame = char.HumanoidRootPart.CFrame
					a.Handle.Velocity = Vector3.new(0,0,0)
					a.Handle.Massless = true
					w = Instance.new("Weld",z.Handle)
					w.C0 = w.Parent:FindFirstChildOfClass("Attachment").CFrame
					w.Name = "AccessoryWeld"
					w.Part0 = z.Handle
					a  = w.Parent:FindFirstChildOfClass("Attachment")
					if string.find(a.Name,"Left") then
						if string.find(a.Name,"Shoulder") then
							w.Part1 = char["Left Arm"]
							w.C1 =  char["Left Arm"].LeftShoulderAttachment.CFrame
						end
					elseif string.find(a.Name,"Right") then
						if string.find(a.Name,"Shoulder") then
							w.Part1 = char["Right Arm"]
							w.C1 =  char["Right Arm"].RightShoulderAttachment.CFrame
						end
					elseif string.find(a.Name,"Left") then
						if string.find(a.Name,"Foot") then
							w.Part1 = char["Left Leg"]
							w.C1 =  char["Left Leg"].LeftFootAttachment.CFrame
						end
					elseif string.find(a.Name,"Right") then
						if string.find(a.Name,"Foot") then
							w.Part1 = char["Right Leg"]
							w.C1 =  char["Right Leg"].RightFootAttachment.CFrame
						end
					elseif string.find(a.Name,"Waist") then
						if string.find(a.Name,"Back") then
							w.Part1 = char["Torso"]
							w.C1 =  char["Torso"].WaistBackAttachment.CFrame
						elseif string.find(a.Name,"Center") then 
							w.Part1 = char["Torso"]
							w.C1 =  char["Torso"].WaistCenterAttachment.CFrame
						end    
					elseif string.find(a.Name,"Body") then
						if string.find(a.Name,"Back") then
							w.Part1 = char["Torso"]
							w.C1 =  char["Torso"].BodyBackAttachment.CFrame
						elseif  string.find(a.Name,"Front") then
							w.Part1 = char["Torso"]
							w.C1 =  char["Torso"].BodyFrontAttachment.CFrame
						end    
					elseif string.find(a.Name,"Hat") then
						w.Part1 = char["Head"]
						w.C1 =  char["Head"].HatAttachment.CFrame 
					elseif string.find(a.Name,"FaceFront") then
						w.Part1 = char["Head"]
						w.C1 =  char["Head"].FaceFrontAttachment.CFrame 
					elseif string.find(a.Name,"FaceCenter") then
						w.Part1 = char["Head"]
						w.C1 =  char["Head"].FaceCenterAttachment.CFrame 
					elseif string.find(a.Name,"Neck") then
						w.Part1 = char["Torso"]
						w.C1 =  char["Torso"].NeckAttachment.CFrame 
					elseif string.find(a.Name,"Hair") then
						w.Part1 = char["Head"]
						w.C1 =  char["Head"].HairAttachment.CFrame 
					end
				end
			end
		end
	end
	for _, child in pairs(char:GetChildren()) do
		if child:IsA("BasePart") then
			child.Transparency = 1
		end
	end
	for _, child in pairs(char:GetChildren()) do
		if child:IsA("Accessory") then
			child.Handle.Transparency = 1
		end
	end
	for _, child in pairs(c:GetChildren()) do
		if child:IsA("Accessory") then
			child.Handle:BreakJoints()
		end
	end
	for i,v in tools do
		table.remove(tools,table.find(tools,v))
	end
	for i,v in pairs(lp.Backpack:GetChildren()) do 
		if v:IsA("Tool") and not string.find(v.Name,"FAKE")  then 
			pcall(function()
				v.Handle.CanCollide = false
			end)
			table.insert(tools,v)
		end 
	end
	for i,v in tools do
		pcall(function()
			v.Parent = c 
			v.Parent = lp.Backpack
			v.Parent = c 
			v.Parent = lp.Backpack
			if not char:FindFirstChild("FAKE"..v.Name) then 
				local fv = v:Clone()
				task.wait(.001)
				fv.Parent = lp.Backpack 
				local oldn = fv.Name 
				fv.Name = "FAKE"..oldn
				table.insert(faketools,fv)
				pcall(function()
					fv.Handle.Transparency = 1 
				end)
			end
			v.Handle.CFrame = char.HumanoidRootPart.CFrame *CFrame.new(0,-25,5)
		end)
	end
	task.spawn(function()
		task.wait(.01)
		for i,v in tools do
			v.Parent = c
		end
		for i,v in tools do
			v.Parent = lp.Backpack
		end
		c:BreakJoints()	
		for i,v in tools do
			v.Parent = c
		end
	end)
	task.spawn(function()	
		task.wait(.02)
		game:GetService("Players").LocalPlayer.Character=char 
        pcall(function()
           moveloop:Disconnect()
           end)
	end)
	local burgermeat = false 
	local clock = os.clock
	local rad, cos, sin, random = math.rad, math.cos, math.sin, math.random
	AntiSleepRotate = Vector3.new(0, sin(clock()*10), 0)
	local plrs = game:GetService("Players")
		if _G.ToolFling == false then
		velocity = game:GetService("RunService").Heartbeat:Connect(function()
			plrs.LocalPlayer.SimulationRadius = #plrs:GetChildren()*1000
			for i,v in pairs(c:GetChildren()) do
				if v:IsA("BasePart") then 
					v.CanCollide = false 
				end
				if v:IsA("Accessory") or v:IsA("Tool") then
					pcall(function()
							v.Handle.AssemblyLinearVelocity = Vector3.new(char.Torso.AssemblyLinearVelocity.X*15 -(10*math.cos(os.clock()*1000))   ,26.5912+math.sin(os.clock()*1000), char.Torso.AssemblyLinearVelocity.Z*15 +6) 
						v.Handle.AssemblyAngularVelocity = Vector3.new(0, sin(clock()*10), 0) + char.Torso.AssemblyAngularVelocity * 10
						v.Handle.CanCollide = false
					end)
				end
			end
		end)
	else 
		velocity = game:GetService("RunService").Heartbeat:Connect(function()
			for i,v in pairs(c:GetChildren()) do
				if v:IsA("BasePart") then 
					v.CanCollide = false 
				end
				if v:IsA("Accessory")  then
						v.Handle.AssemblyLinearVelocity = Vector3.new(char.Torso.AssemblyLinearVelocity.X*15 -(10*math.cos(os.clock()*1000))   ,26.5912+math.sin(os.clock()*1000), char.Torso.AssemblyLinearVelocity.Z*15 +6) 
						v.Handle.AssemblyAngularVelocity = Vector3.new(0, sin(clock()*10), 0) + char.Torso.AssemblyAngularVelocity * 10
						v.Handle.CanCollide = false
				elseif v:IsA("Tool") then 
					if burgermeat == true then
						pcall(function()
							v.Handle.AssemblyLinearVelocity = Vector3.new(9e9 -9e7, 9e9) 
							v.Handle.AssemblyAngularVelocity = Vector3.new(9e9 -9e7, 9e9) 
							v.Handle.CanCollide = false
						end)
					else 
						v.Handle.AssemblyLinearVelocity = Vector3.new(char.Torso.AssemblyLinearVelocity.X*15 -5   , 35.499+math.sin(os.clock()*100), char.Torso.AssemblyLinearVelocity.Z*15 +5) 
						v.Handle.AssemblyAngularVelocity = char.Torso.AssemblyAngularVelocity
					end
				end
			end
		end)
	end
	pcall(function()
		char["Accessory (sapphireTophatAccessory)"].Handle.AccessoryWeld.C0 = CFrame.new(0,0,0) 
		char["Accessory (sapphireTophatAccessory)"].Handle.AccessoryWeld.C1 = CFrame.new(0,0,0)*  CFrame.Angles(0,math.rad(-90),math.rad(90))
   end)
   
	--wait(game:GetService("Players").RespawnTime + 0.25)  
	local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/TypicallyAUser/TypicalsConvertingLibrary/main/Main"))()
	local removinghealth = false
	local sin = math.sin
	local plrs = game:GetService("Players")
    local antisleepMultiplier=Vector3.new(.0045,.005,.0045)
	_G.HeadAngle = CFrame.Angles(0,0,0)
	if _G.CustomHats == false then
		connect = game:GetService("RunService").Heartbeat:Connect(function(set)
			sine=os.clock
			flingpart = _G.flingpart
			pcall(function()
				if flingpart ~= nil and flingpart.Parent.Parent ~= nil then
					if flingpart.Parent:FindFirstChildOfClass("Humanoid") then
						if flingpart.Name ~= "Torso" or flingpart.Name ~= "HumanoidRootPart" or flingpart.Name ~= "Handle" then
							if flingpart.Parent:FindFirstChildOfClass("Humanoid") then
								flingpart = flingpart.Parent.HumanoidRootPart
							end
						end
					end 
				else 
					flingpart = nil
				end
			end)
			local antisleep=Vector3.new(0.0065*sin(sine()*15),0.004*sin(sine()*10),0.0065*math.cos(sine()*10))
			pcall(function()
				workspace.CurrentCamera.CameraSubject = workspace.non:FindFirstChildOfClass("Humanoid")
				workspace.FallenPartsDestroyHeight = oldh 
			end)
			pcall(function()
				c["Tor"].Handle.CFrame = char["Torso"].CFrame   + antisleep
			end)
			pcall(function()
				if nlia == false then 
					c["gooblet"].Handle.CFrame = char["Left Arm"].CFrame * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))  +antisleep
				else 
					c["gooblet"].Handle.CFrame = char["Left Arm"].CFrame * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))  +antisleep
				end
			end)
			pcall(function()
				if nria == false then 
					c["fooblet"].Handle.CFrame = char["Right Arm"].CFrame * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))+antisleep
				else 
					c["fooblet"].Handle.CFrame = char["Right Arm"].CFrame * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))+antisleep
				end
			end)
			pcall(function()
				c["Accessory (rightleg)"].Handle.CFrame = char["Right Leg"].CFrame  * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))  +antisleep
			end)
			pcall(function()
				c["Accessory (LLeg)"].Handle.CFrame = char["Left Leg"].CFrame  * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))  +antisleep
			end)
	
			pcall(function()
				for _,v in pairs(c:GetChildren()) do
					if v:IsA("Accessory") and v.Name ~= "gooblet"  and v.Name ~= "fooblet"  and v.Name ~= "BlueRobotArm" and not string.find(v.Name,"Accessory (Noob") and v.Name ~= "Accessory (NoobLeftArm)"  and v.Name ~= "Accessory (NoobTorso)"  and v.Name ~= "Accessory (NoobRightArm)" and v.Name ~= "GreyRobotArm"   and v.Name ~= "Tor" and v.Name ~= "PurpleRobotArm" and v.Name ~= "RobotArmTest"  and v.Name ~= "LARM" and v.Name ~= "RARM" and v.Name ~= "Accessory (rightleg)" and v.Name ~= "Accessory (LLeg)" then  
						v.Handle.CFrame = char[v.Name].Handle.CFrame +antisleep
						v.Handle.CanTouch = false
					end
				end
			end)
			pcall(function()
				for _,v in pairs(char:GetChildren()) do
					if v:IsA("Accessory") and v.Name ~= "gooblet" and not string.find(v.Name, "gooblet") and v.Name ~= "fooblet" and v.Name ~= "Black"  and v.Name ~= "Tor"  and v.Name ~= "BlueRobotArm" and v.Name ~= "GreyRobotArm"   and v.Name ~= "Tor" and v.Name ~= "PurpleRobotArm" and v.Name ~= "RobotArmTest"  and v.Name ~= "LARM" and v.Name ~= "RARM" and v.Name ~= "Accessory (rightleg)" and v.Name ~= "Accessory (LLeg)" then  
						if not c:FindFirstChild(v.Name) then 
							v.Handle.Transparency = 0.5
						end
					end
				end
				if not c:FindFirstChild("gooblet") then 
					char["Left Arm"].Transparency = 0.5
				end 
				if not c:FindFirstChild("fooblet") then 
					pcall(function()
						char["Right Arm"].Transparency = 0.5
					end)
				end 
				if not c:FindFirstChild("Accessory (rightleg)") then 
					char["Right Leg"].Transparency = 0.5
				end 
				if not c:FindFirstChild("Accessory (LLeg)") then 
					char["Left Leg"].Transparency = 0.5
				end 
				if not c:FindFirstChild("Tor") then 
					char["Torso"].Transparency = 0.5
				end 
			end)
			pcall(function()
					for _,v in pairs(c:GetChildren()) do
						if v:IsA("Accessory")   then
							v.Handle.CanCollide = false
							v.Handle:ApplyImpulseAtPosition(Vector3.new(2,2,2),Vector3.zero)
						end
					end
			end)
			for i,v in pairs(c:GetChildren()) do
				if v:IsA("Tool")  then
					pcall(function()
						if not char:FindFirstChild("FAKE"..v.Name) then
							v.Handle.CFrame = char.HumanoidRootPart.CFrame *CFrame.new(0,-50,0)
						else 
							if _G.ToolFling == true then
								v.Handle.CFrame = cfAdd(flingpart.CFrame,flingpart.AssemblyLinearVelocity*(sin(sine()*15)+1))
							else 
								v.Handle.CFrame = char:FindFirstChild("FAKE"..v.Name).Handle.CFrame + antisleep  
							end
						end
					end)
				end
			end
			settings().Physics.AllowSleep = false
		end)
	else 
		connect = game:GetService("RunService").Heartbeat:Connect(function(set)
			sine=os.clock
			flingpart = _G.flingpart
			pcall(function()
				if flingpart ~= nil and flingpart.Parent.Parent ~= nil then
					if flingpart.Parent:FindFirstChildOfClass("Humanoid") then
						if flingpart.Name ~= "Torso" or flingpart.Name ~= "HumanoidRootPart" or flingpart.Name ~= "Handle" then
							if flingpart.Parent:FindFirstChildOfClass("Humanoid") then
								flingpart = flingpart.Parent.HumanoidRootPart
							end
						end
					end 
				else 
					flingpart = nil
				end
			end)
			local antisleep=Vector3.new(0.0065*sin(sine()*15),0.004*sin(sine()*10),0.0065*math.cos(sine()*10))
			pcall(function()
				workspace.CurrentCamera.CameraSubject = workspace.non:FindFirstChildOfClass("Humanoid")
				workspace.FallenPartsDestroyHeight = oldh 
			end)
			pcall(function()
                                                    						if char["Torso"]:FindFirstChildOfClass("SpecialMesh") then 
                        c["Tor"].Handle.CFrame = char["Torso"].CFrame  * _G.CH.Torso.Orientation  +antisleep+ char["Torso"]:FindFirstChildOfClass("SpecialMesh").Offset
                    else
                     c["Tor"].Handle.CFrame = char["Torso"].CFrame  * _G.CH.Torso.Orientation  +antisleep
                    end
			end)
			pcall(function()
                                    						if char["Left Arm"]:FindFirstChildOfClass("SpecialMesh") then 
                        c["gooblet"].Handle.CFrame = char["Left Arm"].CFrame  * _G.CH.LeftArm.Orientation  +antisleep+ char["Left Arm"]:FindFirstChildOfClass("SpecialMesh").Offset
                    else
                     c["gooblet"].Handle.CFrame = char["Left Arm"].CFrame  * _G.CH.LeftArm.Orientation  +antisleep
                    end
			end)
			pcall(function()
                               						if char["Right Arm"]:FindFirstChildOfClass("SpecialMesh") then 
                        c["fooblet"].Handle.CFrame = char["Right Arm"].CFrame  * _G.CH.RightArm.Orientation  +antisleep+ char["Right Arm"]:FindFirstChildOfClass("SpecialMesh").Offset
                    else
                     c["fooblet"].Handle.CFrame = char["Right Arm"].CFrame  * _G.CH.RightArm.Orientation  +antisleep
                    end
                			end)
			pcall(function()
                               						if char["Right Leg"]:FindFirstChildOfClass("SpecialMesh") then 
                        c["Accessory (rightleg)"].Handle.CFrame = char["Right Leg"].CFrame  * _G.CH.RightLeg.Orientation  +antisleep+ char["Right Leg"]:FindFirstChildOfClass("SpecialMesh").Offset
                    else
                     c["Accessory (rightleg)"].Handle.CFrame = char["Right Leg"].CFrame  * _G.CH.RightLeg.Orientation  +antisleep
                    end
			end)
			pcall(function()
                						if char["Left Leg"]:FindFirstChildOfClass("SpecialMesh") then 
                        c["Accessory (LLeg)"].Handle.CFrame = char["Left Leg"].CFrame  * _G.CH.LeftLeg.Orientation  +antisleep+ char["Left Leg"]:FindFirstChildOfClass("SpecialMesh").Offset
                    else
                     c["Accessory (LLeg)"].Handle.CFrame = char["Left Leg"].CFrame  * _G.CH.LeftLeg.Orientation  +antisleep
                    end
            	pcall(function()
				           						if char["Head"]:FindFirstChildOfClass("SpecialMesh") then 
                        c[_G.CH.Head.Name].Handle.CFrame = char["Head"].CFrame  * _G.CH.Head.Orientation  +antisleep+ char["Head"]:FindFirstChildOfClass("SpecialMesh").Offset 
                    else
                     c[_G.CH.Head.Name].Handle.CFrame = char["Head"].CFrame * _G.CH.Head.Orientation +antisleep
                    end
			end)
			end)
			pcall(function()
				for _,v in pairs(c:GetChildren()) do
					if v:IsA("Accessory") and v.Name ~= "gooblet" and v.Name ~= "fooblet"  and v.Name ~= "BlueRobotArm" and not string.find(v.Name,"Accessory (Noob") and v.Name ~= _G.CH.Head.Name and v.Name ~= "Accessory (NoobLeftArm)"  and v.Name ~= "Accessory (NoobTorso)"  and v.Name ~= "Accessory (NoobRightArm)" and v.Name ~= "GreyRobotArm"   and v.Name ~= "Tor" and v.Name ~= "PurpleRobotArm" and v.Name ~= "RobotArmTest"  and v.Name ~= "LARM" and v.Name ~= "RARM" and v.Name ~= "Accessory (rightleg)" and v.Name ~= "Accessory (LLeg)" then  
								if char[v.Name].Handle:FindFirstChildOfClass("SpecialMesh") then 
                        v.Handle.CFrame = char[v.Name].Handle.CFrame +antisleep + char[v.Name].Handle:FindFirstChildOfClass("SpecialMesh").Offset
                    else
                        v.Handle.CFrame = char[v.Name].Handle.CFrame +antisleep
                    end
						v.Handle.CanTouch = false
					end
				end
			end)
			pcall(function()
				for _,v in pairs(char:GetChildren()) do
					if v:IsA("Accessory") and v.Name ~= "gooblet" and not string.find(v.Name, "gooblet") and v.Name ~= "fooblet" and v.Name ~= "Black"  and v.Name ~= "Tor"  and v.Name ~= "BlueRobotArm" and v.Name ~= "GreyRobotArm"   and v.Name ~= "Tor" and v.Name ~= "PurpleRobotArm" and v.Name ~= "RobotArmTest"  and v.Name ~= "LARM" and v.Name ~= "RARM" and v.Name ~= "Accessory (rightleg)" and v.Name ~= "Accessory (LLeg)" then  
						if not c:FindFirstChild(v.Name) then 
							v.Handle.Transparency = 0.5
						end
					end
				end
				if not c:FindFirstChild("gooblet") then 
					char["Left Arm"].Transparency = 0.5
				end 
				if not c:FindFirstChild("fooblet") then 
					pcall(function()
						char["Right Arm"].Transparency = 0.5
					end)
				end 
				if not c:FindFirstChild("Accessory (rightleg)") then 
					char["Right Leg"].Transparency = 0.5
				end 
				if not c:FindFirstChild("Accessory (LLeg)") then 
					char["Left Leg"].Transparency = 0.5
				end 
				if not c:FindFirstChild("Tor") then 
					char["Torso"].Transparency = 0.5
				end 
			end)
			pcall(function()
				if _G.SBV4R == false then
					for _,v in pairs(c:GetChildren()) do
						if v:IsA("Accessory")   then
							v.Handle.CanCollide = false
							v.Handle:ApplyImpulseAtPosition(Vector3.one,Vector3.zero)
						end
					end
				else
					for _,v in pairs(c:GetChildren()) do
						if v:IsA("Accessory")   then
							v.Handle.CanCollide = false
						end
					end
					c["fooblet"].Handle.Material = 1584
					c["fooblet"].Handle.Color = char["Right Arm"].Color
				end
			end)
			for i,v in pairs(c:GetChildren()) do
				if v:IsA("Tool")  then
					pcall(function()
						if not char:FindFirstChild("FAKE"..v.Name) then
							v.Handle.CFrame = char.HumanoidRootPart.CFrame *CFrame.new(0,-50,0)
						else 
							if _G.ToolFling == true then
								v.Handle.CFrame = cfAdd(flingpart.CFrame,flingpart.AssemblyLinearVelocity*(sin(sine()*15)+1))
							else 
								v.Handle.CFrame = char:FindFirstChild("FAKE"..v.Name).Handle.CFrame + antisleep  
							end
						end
					end)
				end
			end
			settings().Physics.AllowSleep = false
		end)
	end
	local qr = 0
	task.spawn(function()
		task.wait(.05)
		qr = qr + .05
	end)
	char:FindFirstChildOfClass("Humanoid").Died:Connect(function()
		stopped = true
		_G.Stopped = true
		respawnloop:Disconnect()
		for i,v in pairs(char:GetChildren()) do 
		    if v:IsA("Accessory") then
		        v.Handle.CanCollide = true
		        v.Handle:ApplyImpulse(v.Handle.CFrame.LookVector * 5)
		    end 
	    end
		replicatesignal(game:GetService("Players").LocalPlayer.ConnectDiedSignalBackend)
		task.wait(game:GetService("Players").RespawnTime - qr)
		connect:Disconnect()
		char:Destroy()
		velocity:Disconnect()
	end)
	settings().Physics.AllowSleep = false
	for _, child in pairs(c:GetChildren()) do
		if child:IsA("Part") then
			child.Anchored = false
		elseif child:IsA("Accessory") then
			child.Handle.Anchored = false
		end
	end
	local n = 0
	task.spawn(function()
		task.wait(1.5)
		burgermeat = true 
	end)
	local function transparent() 
		for _, child in pairs(char:GetChildren()) do
			local v = child
			if child:IsA("BasePart") and not v:IsA("Model") and v.Name == "Torso" or  child:IsA("BasePart") and v.Name == "Right Arm" or  child:IsA("BasePart") and v.Name == "Left Arm" or  child:IsA("BasePart") and v.Name == "Right Leg" or  child:IsA("BasePart") and v.Name == "Left Leg" then
				if _G.TransparentRig == true then
					child.Transparency = .5
				else 
					child.Transparency = 1 
				end
			end
		end
		for _, child in pairs(char:GetChildren()) do
			local v = child
			if child:IsA("Accessory") and v.Name ~= "Black" then
				if _G.TransparentRig == true then
					child.Handle.Transparency = .5
				else 
					child.Handle.Transparency = 1 
				end
			end
		end
	end
end
redo()
game:GetService("StarterGui"):SetCore("SendNotification", {
	Title = "Oxide Reanimation V3.6 - Respawn Time";
	Duration = 20;
	Text = "Your character will respawn every "..game:GetService("Players").RespawnTime.." seconds."
})
local sin=math.sin
local oldh = workspace.FallenPartsDestroyHeight
respawnloop = plr.CharacterAdded:Connect(function(re)
	if re ~= char then
		if _G.HatCollide == false then 
            repeat wait() until re:FindFirstChildOfClass("Humanoid")
            moveloop = game:GetService("RunService").Heartbeat:Connect(function()
         char:FindFirstChildOfClass("Humanoid"):Move(re:FindFirstChildOfClass("Humanoid").MoveDirection)   
    end)
    end
	replicatesignal(game:GetService("Players").LocalPlayer.ConnectDiedSignalBackend)
	task.wait(game:GetService("Players").RespawnTime)
		if  _G.ToolFling == true then 
			_G.Fling = false 
		end
		for i,v in pairs(lp.Backpack:GetDescendants()) do 
			if v:IsA("Sound") and v:FindFirstAncestorOfClass("Tool") then 
				v.Volume = 0 
			end 
		end
        if _G.HatCollide == false then
		repeat wait() until plr.Character:FindFirstChild("Head")
		workspace.CurrentCamera.CameraSubject = workspace.non:FindFirstChild("Humanoid")
		repeat wait() until plr.Character:FindFirstChildOfClass("Accessory")
        end
		if _G.HideCharacter == false then
			if plr.Character.Name ~= "non" then
				if workspace:FindFirstChild("non") then
					workspace.CurrentCamera.CameraSubject = workspace.non:FindFirstChild("Humanoid")
					if plr.Character.Name ~= "non" then
						plr.Character.HumanoidRootPart.CFrame = CFrame.new( workspace.non.HumanoidRootPart.CFrame.X +5 , workspace.non.HumanoidRootPart.CFrame.Y, workspace.non.HumanoidRootPart.CFrame.Z +5) 
					end
					task.wait(.005)
					redo2()
				else
					workspace.CurrentCamera.CameraSubject = workspace.Terrain.non:FindFirstChildOfClass("Humanoid")
					if plr.Character.Name ~= "non" then
						plr.Character.HumanoidRootPart.CFrame = CFrame.new( workspace.Terrain.non.HumanoidRootPart.CFrame.X +5 , workspace.Terrain.non.HumanoidRootPart.CFrame.Y, workspace.Terrain.non.HumanoidRootPart.CFrame.Z +5) 
					end
					task.wait(.005)
					redo2()
				end
			end
		else
			workspace.CurrentCamera.CameraSubject = workspace.non:FindFirstChild("Humanoid")
			local flingloop
			local c = re
			if _G.FlingEnabled == true and _G.ToolFling == false and _G.HatCollide == false then 
				if _G.Fling == true  and _G.ToolFling == false then
					local flingpart = _G.flingpart
					local sineee=os.clock()
					if flingpart ~= nil then
						if flingpart.Parent:FindFirstChildOfClass("Humanoid") or flingpart:FindFirstChildOfClass("Humanoid") then
							c.Humanoid:ChangeState(16)
							if flingpart.Name ~= "Torso" or flingpart.Name ~= "HumanoidRootPart" or flingpart.Name ~= "Handle" then
								if flingpart.Parent:FindFirstChildOfClass("Humanoid") then
									flingpart = flingpart.Parent.HumanoidRootPart
								elseif flingpart:IsA("Model") then
									flingpart = flingpart.HumanoidRootPart
									_G.flingplr = tostring(flingpart:FindFirstChildOfClass("Humanoid").DisplayName.." (@"..flingpart.Parent.Name..")")
								end
							end
							flingloop = game:GetService("RunService").Heartbeat:Connect(function()
								sineee=os.clock()
								pcall(function()
									if flingpart:IsA("Part") then 
										c.HumanoidRootPart.CFrame = cfAdd(flingpart.CFrame,flingpart.AssemblyLinearVelocity*(sin(sineee*15)+1))
									end
									c.HumanoidRootPart.Velocity = Vector3.new(9e9,-9e7,9e9)
								end)
							end)
							local n = 0
							workspace.FallenPartsDestroyHeight = 0/0
							repeat 
								wait(.05)
								n=n+.05
							until  flingpart.AssemblyLinearVelocity.X <= 3500 and n >= .5 or n >= 1
							game:GetService("StarterGui"):SetCore("SendNotification", {
								Title = "Oxide Reanimation V3.6 - Fling:";
								Duration = 5;
								Text = "Successfully flung: ".._G.flingplr.." in: "..n.." seconds!"
							})
							flingloop:Disconnect()
							workspace.FallenPartsDestroyHeight = oldh
							for i,v in pairs(c:GetDescendants()) do
								if v:IsA("BasePart") then
									v.AssemblyAngularVelocity = Vector3.new(0,0,0)
									v.AssemblyLinearVelocity = Vector3.new(0,0,0)
								end
							end
						end
					end
					_G.Fling =false
				end
			end
            				for i,v in pairs(c:GetDescendants()) do
						if v:IsA("BasePart") then
							v.AssemblyAngularVelocity = Vector3.new(0,0,0)
							v.AssemblyLinearVelocity = Vector3.new(0,0,0)
						end
					end
				end
			if plr.Character.Name ~= "non" then
				if plr.Character.Name ~= "non" then
					if _G.TeleportCharacter == true then
                        if _G.HatCollide == false then
						plr.Character:WaitForChild("HumanoidRootPart").CFrame =CFrame.new( workspace.non.HumanoidRootPart.CFrame.X + 5 , workspace.FallenPartsDestroyHeight + 485, workspace.non.HumanoidRootPart.CFrame.Z  ) 
                        else 
							plr.Character:WaitForChild("HumanoidRootPart").CFrame =CFrame.new( workspace.non.HumanoidRootPart.CFrame.X + 5 , workspace.FallenPartsDestroyHeight + 490, workspace.non.HumanoidRootPart.CFrame.Z  ) 
					end
                end
	                local c =plr.Character
                if c.Name ~= "non" then
				if _G.HatCollide == true then
					c:BreakJoints()
					c:WaitForChild("Humanoid").Health = 0		
				repeat task.wait() until c:FindFirstChildOfClass("Accessory") or not c:IsDescendantOf(workspace)
                end
			end
        if _G.HatCollide == false then
				task.wait(.005)
                else 
                task.wait(.0025)
        end
				workspace.CurrentCamera.CameraSubject = workspace.non:FindFirstChild("Humanoid")
				redo2()
				task.wait(game:GetService("Players").RespawnTime/3)
				if lp.Character ~= workspace.non then 
					moveloop:Disconnect()
					lp.Character:BreakJoints()
					task.wait(.15)
					lp.Character = workspace.non
				end
			end
		end
	end
end)
local flingtable= {}
getgenv().attackuno= function(part)
	task.spawn(function()
		if _G.FlingEnabled == true and stopped == false then
			flingpos = game:GetService("Players").LocalPlayer:GetMouse().Hit
			flingpart = part
			_G.flingplr = nil
			if flingpart.Parent ~= char then
				if flingpart.Parent:FindFirstChildOfClass("Humanoid") then
					_G.flingpart = flingpart
					_G.flingplr = tostring(flingpart.Parent:FindFirstChildOfClass("Humanoid").DisplayName.." (@"..flingpart.Parent.Name..")")
					game:GetService("StarterGui"):SetCore("SendNotification", {
						Title = "Oxide Reanimation V3.6 - Fling:";
						Duration = 3;
						Text = "Locked onto player: "..flingpart.Parent:FindFirstChildOfClass("Humanoid").DisplayName.." (@"..flingpart.Parent.Name..")"
					})
					if _G.ToolFling == true then
						_G.Fling = false
						if faketools[1] ~= nil then 
							faketools[1].Parent = char
						end
						task.wait(2.5)
						if faketools[1] ~= nil then 
							faketools[1].Parent = game:GetService("Players").LocalPlayer.Backpack
						end
						_G.Fling = false 
					else 
						_G.Fling = true
					end
				elseif flingpart:FindFirstChildOfClass("Humanoid") then 
					if not table.find(flingtable,flingpart) then
						table.insert(flingtable,flingpart)
						_G.flingpart = flingpart:FindFirstChild("HumanoidRootPart")
						_G.flingplr = tostring(flingpart:FindFirstChildOfClass("Humanoid").DisplayName.." (@"..flingpart.Name..")")
						game:GetService("StarterGui"):SetCore("SendNotification", {
							Title = "Oxide Reanimation V3.6 - Fling:";
							Duration = 3;
							Text = "Locked onto player: "..flingpart:FindFirstChildOfClass("Humanoid").DisplayName.." (@"..flingpart.Name..")"
						})
_G.Fling = true
						if _G.ToolFling == true then
				q=next(flingtable)
							local flinghigh = Instance.new("Highlight",flingpart)
							if q then
								for i,v in next,table.clone(flingtable) do
								_G.flingpart = v:FindFirstChild("HumanoidRootPart")
              							print(_G.flingpart)
								_G.Fling = false
								if faketools[1] ~= nil then 
									faketools[1].Parent = char
								end
								task.wait(2.5)
								flinghigh:Destroy()
								_G.Fling = false
								flingtable[i] = nil
							end
							if faketools[1] ~= nil then 
								faketools[1].Parent = game:GetService("Players").LocalPlayer.Backpack
							end
end
						else 
							_G.Fling = true
						end
end
				else
					print("not a player")
					_G.Fling = false
				end
			end
		end
	end)
print(_G.Fling)
end
if _G.AntiFling == true then 
	local speaker = game:GetService("Players").LocalPlayer
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	antifling = RunService.Stepped:Connect(function()
		for _, player in pairs(Players:GetPlayers()) do
			if player ~= speaker and player.Character then
				for _, v in pairs(player.Character:GetChildren()) do
					if v:IsA("BasePart") then
						v.CanCollide = false
					elseif v:IsA("Tool") then
						v.Handle.CanCollide = false
					end
				end
			end
		end
	end)
end
local Mouse = game:GetService("Players").LocalPlayer:GetMouse()
Mouse.Button1Down:Connect(function()
	if _G.FlingEnabled == true and stopped == false and _G.ClickFling == true then
		attackuno(Mouse.Target)
	end
end)
local uis = game:GetService("UserInputService")
uis.InputBegan:Connect(function(k,chatting)
	if chatting then return end
if k.KeyCode == Enum.KeyCode.Minus then 
	replicatesignal(game:GetService("Players").LocalPlayer.ConnectDiedSignalBackend)
	task.wait(game:GetService("Players").RespawnTime)
	connect:Disconnect()
	velocity:Disconnect()
end
end)
_G.OxideFakeChar:ScaleTo(_G.Scale)
_G.OxideRealChar:ScaleTo(1)
task.wait(3)
_G.OxideFakeChar:ScaleTo(1)
task.wait(game.Players.RespawnTime*2)
local reclaim = true --if you lost control over a part this will move your primary part to the part so you get it back
local novoid = true --prevents parts from going under workspace.FallenPartsDestroyHeight if you control them
local antiragdoll = true --removes instances that are usually used for ragdolling form your character
local addPartsOnRun = false --allows u to add more parts and joints to the simulation after it started
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --adds fake r6 parts and joints for animations if your character is r15
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local walkSpeed = 16 --your walkspeed (can be changed at runtime)
local jumpPower = 50 --your jump power (can be changed at runtime)
local allowshiftlock = true --allows the user to use shiftlock (can be changed at runtime)
local gravity = 196.2 --how fast the characters velocity increases while falling (can be changed at runtime)
local simrad = 1000 --sets simulation radius to this with sethiddenproperty (nil to disable)
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay for method 1
local method = 0 --reanimation method
local ctrlclicktp = true --makes you teleport where u point ur mouse cursor at when click and hold ctrl down
local clickfling = 2 --click fling mode
local maxflingtrsp = 0.5 --max transparency of the fling part (if its above this it will be set to this)

local ws, rs = game:GetService("Workspace"), game:GetService("RunService")
local plrs, uis = game:GetService("Players"), game:GetService("UserInputService")
local lp, gs = plrs.LocalPlayer, game:GetService("GuiService")
local stepped, heartbeat, renderstepped = rs.Stepped, rs.Heartbeat, rs.RenderStepped
local twait, tdelay, tspawn = task.wait, task.delay, task.spawn
local tinsert, tfind, osclock = table.insert, table.find, os.clock
local sin, abs, sine, clamp, mrandom = math.sin, math.abs, osclock(), math.clamp, math.random
local cf, v3, angles = CFrame.new, Vector3.new, CFrame.Angles
local v3_0, v3_101, v3_010, v3_001, cf_0 = v3(0, 0, 0), v3(1, 0, 1), v3(0, 1, 0), v3(0, 0, 1), cf(0, 0, 0)
local c = lp.Character
if not c then return end
if not c:IsDescendantOf(ws) then return end
local c1 = c
c.AncestryChanged:Connect(function()
    if c1 then
        if c1:IsDescendantOf(ws) then
            c = c1
        else
            c = nil
        end
    end
end)
local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end
local hum = c:FindFirstChildOfClass("Humanoid")
local rootpart = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart") or (hum and hum.RootPart) or c:FindFirstChildWhichIsA("BasePart")
if not rootpart then return end
local head, torso = gp(c, "Head", "BasePart"), gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")

reclaim = reclaim and (c.PrimaryPart or rootpart)
novoid = novoid and (ws.FallenPartsDestroyHeight + 1)
flingparts = ((type(flingparts) == "table") and flingparts) or ((type(flingparts) == "string") and {flingparts}) or {}
local hatcollide = (method == 1)
R15toR6 = R15toR6 and hum and (hum.RigType == Enum.HumanoidRigType.R15)
local shp = getfenv().sethiddenproperty
simrad = shp and tonumber(simrad)

if hatcollide then
    for i, v in pairs(flingparts) do
        flingparts[i] = gp(c, v, "BasePart") or gp(gp(c, v, "Accessory"), "Handle", "BasePart") or {Anchored = true}
    end
    lp.Character = nil
    lp.Character = c
    twait(loadtime)
else
    for i, v in pairs(flingparts) do
        flingparts[i] = gp(c, v, "BasePart") or {Anchored = true}
    end
    if method == 2 then
        if hum then
            hum:Destroy()
            hum = nil
        end
    end
end

if not c then return end

local cam = ws.CurrentCamera
local enumCamS, camt, camcf = Enum.CameraType.Scriptable, cam.CameraType, cam.CFrame
local camcon0, camcon1 = nil, nil
local function onnewcamera()
    if camcon0 then 
        camcon0:Disconnect()
        camcon0 = nil
    end
    cam = ws.CurrentCamera
    if not c then 
        if cam.CameraType == enumCamS then
            cam.CameraType = camt
        end
        return camcon1:Disconnect() 
    end
    camcon0 = cam.Changed:Connect(function(p)
        if not c then
            camcon0:Disconnect()
            return camcon1:Disconnect()
        end
        if (p == "CFrame") and (cam.CFrame ~= camcf) then
            cam.CFrame = camcf
        elseif (p == "CameraSubject") or (p == "CameraType") then
            local subj = cam.CameraSubject
            if subj and subj:IsA("Humanoid") and (subj.Parent == c) and (cam.CameraType ~= enumCamS) then
                cam.CameraType = enumCamS
            end
        end
    end)
    local subj = cam.CameraSubject
    if subj and subj:IsA("Humanoid") and (subj.Parent == c) and (cam.CameraType ~= enumCamS) then
        cam.CameraType = enumCamS
    end
    cam.CFrame = camcf
end
camcon1 = ws:GetPropertyChangedSignal("CurrentCamera"):Connect(onnewcamera)
onnewcamera()
if discharscripts then
    for i, v in pairs(c:GetChildren()) do
        if v:IsA("LocalScript") then
            v.Disabled = true
        end
    end
end

if humState16 and hum and (hum.Health > 0) then
    hum:ChangeState(16)
end
local keepneck = head and torso and (method == 0)
local joints, cframes, lastpositions = {}, {}, {}
local function ondes(v)
    if antiragdoll and v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
        v:Destroy()
    elseif addPartsOnRun then
        if v:IsA("JointInstance") then
            tinsert(joints, {
                Name = v.Name,
                C0 = v.C0,
                C1 = v.C1,
                Part0 = v.Part0,
                Part1 = v.Part1
            })
            if keepneck then
                if (v.Part0 == head) and (v.Part1 == torso) then
                    return
                elseif (v.Part0 == torso) and (v.Part1 == head) then
                    return
                end
            end
            if not hatcollide then
                v:Destroy()
            end
        elseif v:IsA("BasePart") then
            cframes[v] = v.CFrame
            lastpositions[v] = v.Position
        end
    end
end
if addPartsOnRun then
    for i, v in pairs(c:GetDescendants()) do
        ondes(v)
    end
    c.DescendantAdded:Connect(ondes)
else
    addPartsOnRun = true
    for i, v in pairs(c:GetDescendants()) do
        ondes(v)
    end
    addPartsOnRun = false
    c.DescendantAdded:Connect(ondes)
end

local cfr, shiftlock, firstperson, xzvel, Yvel, v3_0150 = cframes[rootpart], false, false, v3_0, 0, v3_010 * 1.5
local camoff = cf(v3_0, camcf.LookVector)
camoff = camoff - v3_001 * (camcf.Position - (cfr.Position + v3_0150)).Magnitude

if hatcollide then
    if torso and rootpart then
        torso:Destroy()
        rootpart:Destroy()
    end
    for i, v in pairs(c:GetChildren()) do
        if v:IsA("BasePart") then
            v:Destroy()
            hatcollide = false
        end
    end
    hatcollide = hatcollide and (c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script") or gp(c, "Animate", "LocalScript"))
    if hatcollide then
        hatcollide:Destroy()
    end
end
local refreshjoints = nil
refreshjoints = function(part, refreshed)
    if not part then return end
    refreshed = refreshed or {}
    tinsert(refreshed, part)
    for i, v in pairs(joints) do
        local part0, part1 = v.Part0, v.Part1
        if part1 and (part0 == part) then
            cframes[part1] = cframes[part] * v.C0 * v.C1:Inverse()
            if not tfind(refreshed, part1) then
                refreshjoints(part1, refreshed)
            end
        elseif part0 and (part1 == part) then
            cframes[part0] = cframes[part] * v.C1 * v.C0:Inverse()
            if not tfind(refreshed, part0) then
                refreshjoints(part0, refreshed)
            end
        end
    end
end

if R15toR6 then
    local R6parts = { 
        head = {Name = "Head", Anchored = true},
        torso = {Name = "Torso", Anchored = true},
        root = {Name = "HumanoidRootPart", Anchored = true},
        leftArm = {Name = "Left Arm", Anchored = true},
        rightArm = {Name = "Right Arm", Anchored = true},
        leftLeg = {Name = "Left Leg", Anchored = true},
        rightLeg = {Name = "Right Leg", Anchored = true}
    }
    for i, v in pairs(R6parts) do
        cframes[v] = cfr
    end
    tinsert(joints, {
        Name = "Neck",
        Part0 = R6parts.torso, Part1 = R6parts.head,
        C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
        C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
    })
    tinsert(joints, {
        Name = "RootJoint" ,
        Part0 = R6parts.root, Part1 = R6parts.torso,
        C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
        C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
    })
    tinsert(joints, {
        Name = "Right Shoulder",
        Part0 = R6parts.torso, Part1 = R6parts.rightArm,
        C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
        C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
    })
    tinsert(joints, {
        Name = "Left Shoulder",
        Part0 = R6parts.torso, Part1 = R6parts.leftArm,
        C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
        C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
    })
    tinsert(joints, {
        Name = "Right Hip",
        Part0 = R6parts.torso, Part1 = R6parts.rightLeg,
        C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
        C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
    })
    tinsert(joints, {
        Name = "Left Hip" ,
        Part0 = R6parts.torso, Part1 = R6parts.leftLeg,
        C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
        C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
    })
    tinsert(joints, {
        Part0 = R6parts.root, Part1 = rootpart,
        C0 = cf_0, C1 = cf_0
    })
    refreshjoints(rootpart)
    local function getpart(name)
        for i, _ in pairs(cframes) do
            if (i.Name == name) and (type(i) ~= "table") then
                return i
            end
        end
        return nil
    end
    local function makejoint(p0, p1, p2)
        p1, p2 = getpart(p1), getpart(p2)
        if not (p1 and p2) then return end
        for i, v in pairs(joints) do
            if (v.Part0 == p1) and (v.Part1 == p2) then
                joints[i] = nil
            elseif (v.Part0 == p2) and (v.Part1 == p1) then
                joints[i] = nil
            end
        end
        tinsert(joints, {
            Part0 = p0, Part1 = p1,
            C0 = cf_0,
            C1 = cframes[p1]:Inverse() * cframes[p0]
        })
    end
    makejoint(R6parts.head, "Head", "UpperTorso")
    makejoint(R6parts.leftArm, "LeftUpperArm", "UpperTorso")
    makejoint(R6parts.rightArm, "RightUpperArm", "UpperTorso")
    makejoint(R6parts.leftLeg, "LeftUpperLeg", "LowerTorso")
    makejoint(R6parts.rightLeg, "RightUpperLeg", "LowerTorso")
    makejoint(R6parts.torso, "LowerTorso", "HumanoidRootPart")
end

local raycastparams = RaycastParams.new()
raycastparams.FilterType = Enum.RaycastFilterType.Blacklist
local rayfilter = {}
local characters = {}
local function refreshrayfilter()
    for i, v in pairs(rayfilter) do
        if not tfind(characters, v) then
            rayfilter[i] = nil
        end
    end
    for i, v in pairs(characters) do
        if not tfind(rayfilter, v) then
            tinsert(rayfilter, v)
        end
    end
    raycastparams.FilterDescendantsInstances = rayfilter
end
local function oncharacter(plr, c)
    characters[plr] = c
    refreshrayfilter()
end
local function onplayer(v)
    oncharacter(v, v.Character)
    v.CharacterAdded:Connect(function(c)
        oncharacter(v, c)
    end)
end
for i, v in pairs(plrs:GetPlayers()) do onplayer(v) end
plrs.PlayerAdded:Connect(onplayer)
plrs.PlayerRemoving:Connect(function(v)
    oncharacter(v, nil)
end)

local mradN05 = math.rad(-0.5)
local enumMLC = Enum.MouseBehavior.LockCenter
local enumMB2 = Enum.UserInputType.MouseButton2
local enumMLCP = Enum.MouseBehavior.LockCurrentPosition
local enumMD = Enum.MouseBehavior.Default
local enumMW = Enum.UserInputType.MouseWheel

local mode, modes = "default", {default = {}}
local function addmode(key, mode)
    if (type(key) ~= "string") or (type(mode) ~= "table") then
        return
    end
    for i, v in pairs(mode) do
        if type(v) ~= "function" then
            mode[i] = nil
        end
    end
    if key == "default" then
        modes.default = mode
        if mode.modeEntered then
            mode.modeEntered()
        end
    elseif #key == 1 then
        key = Enum.KeyCode[key:sub(1, 1):upper()]
        modes[key] = mode
    end
end

local keyW, keyA, keyS, keyD, keySpace, keyShift = Enum.KeyCode.W, Enum.KeyCode.A, Enum.KeyCode.S, Enum.KeyCode.D, Enum.KeyCode.Space, Enum.KeyCode.LeftShift
local movementkeys = {
	[keyW] = false,
	[keyA] = false,
	[keyS] = false,
	[keyD] = false,
	[keySpace] = false
}
uis.InputBegan:Connect(function(a)
	if gs.MenuIsOpen or uis:GetFocusedTextBox() then
		return
	end
    a = a.KeyCode
    if movementkeys[a] == false then
        movementkeys[a] = true
    elseif a == keyShift then
        shiftlock = allowshiftlock and not shiftlock
    elseif modes[a] then
        if modes[mode].modeLeft then
            modes[mode].modeLeft()
        end
        if mode == a then
            mode = "default"
        else
            mode = a
        end
        if modes[mode].modeEntered then
            modes[mode].modeEntered()
        end
    end
end)
uis.InputEnded:Connect(function(a)
	if movementkeys[a.KeyCode] then
		movementkeys[a.KeyCode] = false
	end
end)
uis.InputChanged:Connect(function(a, b)
	if (not b) and (a.UserInputType == enumMW) then
		camoff = camoff + a.Position * v3_001 * (0.75 - camoff.Z / 4)
		if camoff.Z > 0 then
			camoff = camoff - camoff.Position
		end
		firstperson = camoff.Z == 0
	end
end)

local lostPart = nil

local v3_xz, v3_net = v3_101 * 10, v3_010 * 25.01
local function getNetlessVelocity(realPartVelocity)
    --if true then return v3_0 end
    --if true then return realPartVelocity end
    --if true then return v3_net end
    if realPartVelocity.Magnitude > 25.01 then
        realPartVelocity = realPartVelocity.Unit * 25.01
    end
    return realPartVelocity * v3_xz + v3_net
end

local function getJoint(name)
    for i, v in pairs(joints) do
        if v.Name == name then
            return v
        end
    end
    return {C0 = cf_0, C1 = cf_0}
end

local function getAccessoryWeld(hatname)
    local handle = gp(gp(c, hatname, "Accessory"), "Handle", "BasePart")
    if handle then
        for i, v in pairs(joints) do 
            if v.Part0 == handle then
                return v
            end
        end
    end
    return {C0 = cf_0, C1 = cf_0}
end

local defaultflingvel = v3(20000, 20000, 20000)
local mouse, flingcf, flingvel, flingid, currentflingpart = lp:GetMouse(), nil, nil, 0, nil
local function fling(target, duration, rotVelocity)
    currentflingpart = nil
    for i, v in pairs(flingparts) do
        if v and (not v.Anchored) and v:IsDescendantOf(ws) and (v.ReceiveAge == 0) then
            currentflingpart = v
            break
        end
    end
    if not currentflingpart then 
        return twait() and false
    end
    if typeof(target) == "Instance" then
        if target:IsA("BasePart") then
            target = target.Position
        elseif target:IsA("Model") then
            target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
            if target then
                target = target.Position
            else
                return twait() and false
            end
        elseif target:IsA("Humanoid") then
            target = target.Parent
            if not (target and target:IsA("Model")) then
                return twait() and false
            end
            target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
            if target then
                target = target.Position
            else
                return twait() and false
            end
        else
            return twait() and false
        end
    elseif typeof(target) == "CFrame" then
        target = target.Position
    elseif typeof(target) ~= "Vector3" then
        target = mouse.Hit
        if target then
            target = target.Position
        else
            return twait() and false
        end
    end
    if type(duration) ~= "number" then
        duration = tonumber(duration) or 0.5
    end
    if typeof(rotVelocity) ~= "Vector3" then
        rotVelocity = defaultflingvel
    end
    if (type(maxflingtrsp) == "number") and (currentflingpart.Transparency > maxflingtrsp) then
        currentflingpart.Transparency = maxflingtrsp
    end
    flingcf = cf(target)
    flingvel = rotVelocity
    flingid = flingid + 1
    local thisfling = flingid
    twait(duration)
    if flingid == thisfling then
        flingcf = nil
        currentflingpart = nil
    end
    return true
end

local pflingid = 0
local function predictionfling(target, duration, rotVelocity, stopOnVelMag)
    if typeof(target) ~= "Instance" then 
        target = mouse.Target
        if not target then
            return twait() and false
        end
    end
    if target:IsA("Humanoid") or target:IsA("BasePart") then 
        target = target.Parent 
    end
    if target:IsA("Accessory") then
        target = target.Parent
    end
    if (not target:IsA("Model")) or (target == c) then
        return twait() and false
    end
    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart")
    if not (target and target:IsDescendantOf(ws)) then
        return twait() and false
    end
    if stopOnVelMag then
        duration = tonumber(duration) or 5
        stopOnVelMag = tonumber(stopOnVelMag) or 1000
    elseif type(stopOnVelMag) == "boolean" then
        duration = tonumber(duration) or 1
        stopOnVelMag = nil
    else 
        duration = tonumber(duration) or 5
        stopOnVelMag = 1000
    end
    local stopTime = sine + duration
    pflingid = pflingid + 1
    local thisfling = pflingid
    local con = nil
    con = heartbeat:Connect(function(deltaTime)
        if (thisfling ~= pflingid) or (sine > stopTime) or (stopOnVelMag and (target.Velocity.Magnitude > stopOnVelMag)) or (not (target and target:IsDescendantOf(ws))) then
            return con:Disconnect()
        end
        fling(target.Position + target.Velocity * (sin(sine * 15) + 1), 0, rotVelocity)
    end)
    twait()
    return true
end

if ctrlclicktp then
    ctrlclicktp = Enum.KeyCode.LeftControl
    local tpoff = v3_010 * 3
    if clickfling == 0 then
        mouse.Button1Down:Connect(function()
            if uis:IsKeyDown(ctrlclicktp) then
                if mouse.Target then
                    local pos = mouse.Hit.Position + tpoff
                    cfr = cf(pos, pos + camoff.LookVector * v3_101)
                    xzvel = v3_0
                    Yvel = 0
                end
            else
                fling()
            end
        end)
    elseif clickfling == 1 then
        mouse.Button1Down:Connect(function()
            if uis:IsKeyDown(ctrlclicktp) then
                if mouse.Target then
                    local pos = mouse.Hit.Position + tpoff
                    cfr = cf(pos, pos + camoff.LookVector * v3_101)
                    xzvel = v3_0
                    Yvel = 0
                end
            else
                predictionfling()
            end
        end)
    elseif clickfling == 2 then
        mouse.Button1Down:Connect(function()
            if uis:IsKeyDown(ctrlclicktp) then
                if mouse.Target then
                    local pos = mouse.Hit.Position + tpoff
                    cfr = cf(pos, pos + camoff.LookVector * v3_101)
                    xzvel = v3_0
                    Yvel = 0
                end
            elseif not predictionfling() then
                fling()
            end
        end)
    else
        mouse.Button1Down:Connect(function()
            if mouse.Target and uis:IsKeyDown(ctrlclicktp) then
                local pos = mouse.Hit.Position + tpoff
                cfr = cf(pos, pos + camoff.LookVector * v3_101)
                xzvel = v3_0
                Yvel = 0
            end
        end)
    end
else
    if clickfling == 0 then
        mouse.Button1Down:Connect(fling)
    elseif clickfling == 1 then
        mouse.Button1Down:Connect(predictionfling)
    elseif clickfling == 2 then
        mouse.Button1Down:Connect(function()
            if not predictionfling() then fling() end
        end)
    end
end

local noYvelTime, deltaTime, lastsine, pose, con = 1, 0, sine, nil, nil
local function mainFunction()
    if not c then 
        uis.MouseBehavior = enumMD
        onnewcamera()
        local c = lp.Character
        if c then
            cam.CameraSubject = c:FindFirstChildOfClass("Humanoid")
        end
        return con and con:Disconnect() 
    end
    
    sine = osclock()
    local delta = sine - lastsine
    deltaTime = clamp(delta * 10, 0, 1)
    lastsine = sine
    
    if shiftlock then
        if allowshiftlock then
            uis.MouseBehavior = enumMLC
            local rotation = uis:GetMouseDelta() * mradN05
    		camoff = cf(camoff.Position, camoff.Position + camoff.LookVector) * angles(rotation.Y, rotation.X, 0)
    	else
    	    shiftlock = false
    	end
    elseif firstperson then
        uis.MouseBehavior = enumMLC
        local rotation = uis:GetMouseDelta() * mradN05
		camoff = cf(camoff.Position, camoff.Position + camoff.LookVector) * angles(rotation.Y, rotation.X, 0)
    elseif uis:IsMouseButtonPressed(enumMB2) then
        uis.MouseBehavior = enumMLCP
        local rotation = uis:GetMouseDelta() * mradN05
		camoff = cf(camoff.Position, camoff.Position + camoff.LookVector) * angles(rotation.Y, rotation.X, 0)
    else
        uis.MouseBehavior = enumMD
    end
    
    local raycastresult, onground = ws:Raycast(cfr.Position, v3_010 * ws.FallenPartsDestroyHeight - cfr.Position, raycastparams), nil
	if raycastresult then
	    onground = (cfr.Y - raycastresult.Position.Y) < 3.01
		if onground then
		    Yvel = 0
		    cfr = cfr + v3_010 * (raycastresult.Position.Y + 3 - cfr.Y) * clamp(delta * 20, 0, 1)
			if movementkeys[keySpace] then
			    Yvel = jumpPower
			end
	    else
			Yvel = Yvel - gravity * delta
			if cfr.Y + Yvel * delta < raycastresult.Position.Y then
			    Yvel = 0
			    cfr = cfr + v3_010 * (raycastresult.Position.Y + 3 - cfr.Y)
			end
		end
	else
	    Yvel = 0
	    onground = false
	end
	xzvel = v3_0
	if movementkeys[keyW] then
		xzvel = xzvel + (camoff.LookVector * v3_101).Unit
	end
	if movementkeys[keyS] then
		xzvel = xzvel - (camoff.LookVector * v3_101).Unit
	end
	if movementkeys[keyA] then
		xzvel = xzvel - (camoff.RightVector * v3_101).Unit
	end
	if movementkeys[keyD] then
		xzvel = xzvel + (camoff.RightVector * v3_101).Unit
	end
	if xzvel.Magnitude > 0 then
	    xzvel = xzvel.Unit * walkSpeed
    	cfr = cfr:Lerp(cf(cfr.Position, cfr.Position + xzvel), deltaTime)
	end
    if shiftlock or firstperson then
	    cfr = cf(cfr.Position, cfr.Position + camoff.LookVector * v3_101)
    end
	cfr = cfr + (xzvel + v3_010 * Yvel) * delta
	
	camcf = cf(cfr.Position, cfr.Position + camoff.LookVector) + (camoff.LookVector * camoff.Z) + v3_0150
	if shiftlock and not firstperson then
	    camcf = camcf + camcf.RightVector * 1.75
	end
	cam.CFrame = camcf
	
    if onground then
        if xzvel == v3_0 then
            pose = "idle"
        else
            pose = "walk"
        end
    elseif Yvel > 0 then
        pose = "jump"
    else
        pose = "fall"
    end
    local lerpfunc = modes[mode][pose]
    lerpfunc = lerpfunc or modes.default[pose]
    if lerpfunc then
        lerpfunc()
    end
    
    cframes[rootpart] = cfr
    refreshjoints(rootpart)
    
    if abs(Yvel) > 1 then
	    noYvelTime = 0
	else
	    noYvelTime = clamp(noYvelTime + delta, 0, 1)
	    xzvel = xzvel*(1-noYvelTime)
	end
    
    local idleoff = delta / 5
    local x, y, z = sin((sine - 0.01875) * 32) * idleoff, sin(sine * 32) * idleoff, sin((sine + 0.0375) * 32) * idleoff
    idleoff = angles(x, y, z) + v3(x, y, z)
    
    for i, v in pairs(cframes) do
        if (not i.Anchored) and i:IsDescendantOf(ws) then
            if i.ReceiveAge == 0 then
                if (i == currentflingpart) and flingcf then
                    flingcf = flingcf * angles(0, flingvel.Unit.Y * -deltaTime, 0)
                    v = flingcf
                    i.RotVelocity = flingvel
                else
                    i.RotVelocity = v3_0
                end
                local vel = (v.Position - lastpositions[i]) / delta
                lastpositions[i] = v.Position
                if vel.Magnitude < 0.15 then
                    v = v * idleoff
                end
                if (i == reclaim) and lostPart then
                    v = lostPart.CFrame
                    lostPart = nil
                    i.Velocity = v3_0
                else
                    i.Velocity = getNetlessVelocity(vel*noYvelTime + xzvel)
                end
                if novoid and (v.Y < novoid) then
                    v = v + v3_010 * (novoid - v.Y)
                end
                i.CFrame = v
            else
                lastpositions[i] = i.Position
                if reclaim and (i ~= reclaim) then
                    lostPart = i
                end
            end
        end
    end
    if simrad then
        shp(lp, "SimulationRadius", simrad)
    end
end

con = heartbeat:Connect(mainFunction)
mainFunction()

local RootJoint = getJoint("RootJoint")
local RightShoulder = getJoint("Right Shoulder")
local LeftShoulder = getJoint("Left Shoulder")
local RightHip = getJoint("Right Hip")
local LeftHip = getJoint("Left Hip")
local Neck = getJoint("Neck")

local legcfR, legcfL, raydir = cf(1, -1, 0), cf(-1, -1, 0), v3_010 * -2
local function raycastlegs() --this returns 2 values: right leg raycast offset, left leg raycast offset
    local rY, lY = ws:Raycast((cfr * legcfR).Position, raydir, raycastparams), ws:Raycast((cfr * legcfL).Position, raydir, raycastparams)
    return rY and (rY.Position.Y - (cfr.Y-3)) or 0, lY and (lY.Position.Y - (cfr.Y-3)) or 0
end

local function velbycfrvec() --this returns 2 values: forward/backwards movement (from -1 to 1), right/left movement (from -1 to 1)
    local fw, rt = cfr.LookVector * xzvel / walkSpeed, cfr.RightVector * xzvel / walkSpeed
    return fw.X + fw.Z, rt.X + rt.Z
end

local lastvel = v3_0
local velchg1 = v3_0
local function velchgbycfrvec() --this returns 2 values: forward/backwards velocity change, right/left velocity change
    velchg1 = velchg1 + (lastvel - xzvel) --i recommend setting velchg1 to v3_0 when u start using this function or it will look worse
    lastvel = xzvel
    velchg1 = velchg1:Lerp(v3_0, deltaTime / 2)
    local fw, rt = cfr.LookVector * velchg1 / 32, cfr.RightVector * velchg1 / 32
    return fw.X + fw.Z, rt.X + rt.Z
end

	addmode("default", {
		idle = function()
			local rY, lY = raycastlegs()
 
			local Cfw, Crt = velchgbycfrvec()
 
RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
--Neck.C0=Neck.C0:Lerp(cf(0,1,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
LeftShoulder.C0=LeftShoulder.C0:Lerp(cf(0.22 * sin((sine+60)*4),-0.5,0.32 * sin(sine*4))*angles(3.141592653589793+0.17453292519943295*sin(sine*4),0,3.141592653589793+0.17453292519943295*sin((sine+60)*4)),deltaTime) 
RightShoulder.C0=RightShoulder.C0:Lerp(cf(0.55 * sin((sine+60)*4),1.35,0.64 * sin(sine*4))*angles(3.141592653589793+0.17453292519943295*sin(sine*4),0,3.141592653589793+0.17453292519943295*sin((sine+60)*4)),deltaTime) 
RightHip.C0=RightHip.C0:Lerp(cf(-0.5,-1.24,0.05 * sin(sine*4))*angles(0,0,0),deltaTime) 
LeftHip.C0=LeftHip.C0:Lerp(cf(0.5,-1.24,0.05 * sin(sine*4))*angles(0,0,0),deltaTime) 
--MW_animatorProgressSave: Torso,0,0,0,1,-90,0,0,1,0,0,0,1,-0,0,0,1,0,0,0,1,180,0,0,1,MeshPartAccessory_Handle,-0.000867009162902832,0,0,1,180,0,0,1,0.6538610458374023,0,0,1,0,0,0,1,0.024028420448303223,0,0,1,180,0,0,1,LeftArm,0,0.22,60,4,180,10,0,4,-0.5,0,0,4,0,0,0,4,0,0.32,0,4,180,10,60,4,Unloadedhead_Handle,0.000171661376953125,0,0,1,180,0,0,1,0.5999884605407715,0,0,1,0,0,0,1,0.0004730224609375,0,0,1,180,0,0,1,RightArm,0,0.55,60,4,180,10,0,4,1.35,0,0,4,0,0,0,4,0,0.64,0,4,180,10,60,4,Head,0,0,0,1,-90,0,0,1,1,0,0,1,-0,0,0,1,0,0,0,1,180,0,0,1,RightLeg,-0.5,0,0,4,0,0,0,4,-1.24,0,0,4,0,0,0,4,0,0.05,0,4,0,0,0,4,MeshPartAccessory_Handle,0.0003427176852710545,0,0,1,-0,0,0,1,0.593110203742981,0,0,1,0,0,0,1,0.0003814697265625,0,0,1,-0,0,0,1,LeftLeg,0.5,0,0,4,-0,0,0,4,-1.24,0,0,4,0,0,0,4,0,0.05,0,4,0,0,0,4,MeshPartAccessory_Handle,0.0003427176852710545,0,0,1,-0,0,0,1,0.593110203742981,0,0,1,0,0,0,1,0.0003814697265625,0,0,1,-0,0,0,1
end,
		walk = function()
			local Vfw, Vrt = velbycfrvec()
 
			local rY, lY = raycastlegs()
 
			local Cfw, Crt = velchgbycfrvec()
 
RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
RightHip.C0=RightHip.C0:Lerp(cf(-0.5,-0.9-0.6*sin((sine + 260)*8),-0.9 * sin((sine-10.04)*8))*angles(0,0,0),deltaTime) 
LeftShoulder.C0=LeftShoulder.C0:Lerp(cf(0,-0.2-0.6*sin((sine + 260)*8),-1.07 * sin((sine-10)*8))*angles(3.141592653589793+0.2617993877991494*sin((sine-70)*8),0,3.141592653589793),deltaTime) 
RightShoulder.C0=RightShoulder.C0:Lerp(cf(0,1.6-0.6*sin((sine + 260)*8),1.47 * sin((sine+10.055)*8))*angles(3.141592653589793+0.2617993877991494*sin((sine-70)*8),0,3.141592653589793),deltaTime) 
LeftHip.C0=LeftHip.C0:Lerp(cf(0.5,-0.9-0.6*sin((sine + 260)*8),-0.9 * sin((sine-10.04)*8))*angles(0,0,0),deltaTime) 
--Neck.C0=Neck.C0:Lerp(cf(0,1,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
--MW_animatorProgressSave: Torso,0,0,0,2,-90,0,0,2,0,0,0,2,-0,0,0,2,0,0,0,2,180,0,0,2,MeshPartAccessory_Handle,0.0003427176852710545,0,0,2,-0,0,0,2,0.593110203742981,0,0,2,0,0,0,2,0.0003814697265625,0,0,2,-0,0,0,2,RightLeg,-0.5,0,0,8,0,0,0,8,-0.9,-0.6,260,8,0,0,0,8,0,-0.9,-10.04,8,0,0,0,8,MeshPartAccessory_Handle,0.0003427176852710545,0,0,1,-0,0,0,1,0.593110203742981,0,0,1,0,0,0,1,0.0003814697265625,0,0,1,-0,0,0,1,LeftArm,0,0,0,8,180,15,-70,8,-0.2,-0.6,260,8,0,0,0,8,0,-1.07,-10,8,180,0,0,8,RightArm,0,0,0,8,180,15,-70,8,1.6,-0.6,260,8,0,0,0,8,0,1.47,10.055,8,180,0,0,8,LeftLeg,0.5,0,0,8,-0,0,0,8,-0.9,-0.6,260,8,0,0,0,8,0,-0.9,-10.04,8,0,0,0,8,Head,0,0,0,2,-90,0,0,2,1,0,0,2,-0,0,0,2,0,0,0,2,180,0,0,2
end,
		jump = function()
			local Vfw, Vrt = velbycfrvec()
 
			local Cfw, Crt = velchgbycfrvec()
 
RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
--Neck.C0=Neck.C0:Lerp(cf(0,1,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
LeftShoulder.C0=LeftShoulder.C0:Lerp(cf(0.22 * sin((sine+60)*4),-0.5,0.32 * sin(sine*4))*angles(3.141592653589793+0.17453292519943295*sin(sine*4),0,3.141592653589793+0.17453292519943295*sin((sine+60)*4)),deltaTime) 
RightShoulder.C0=RightShoulder.C0:Lerp(cf(0.55 * sin((sine+60)*4),1.35,0.64 * sin(sine*4))*angles(3.141592653589793+0.17453292519943295*sin(sine*4),0,3.141592653589793+0.17453292519943295*sin((sine+60)*4)),deltaTime) 
RightHip.C0=RightHip.C0:Lerp(cf(-0.5,-1.24,0.05 * sin(sine*4))*angles(0,0,0),deltaTime) 
LeftHip.C0=LeftHip.C0:Lerp(cf(0.5,-1.24,0.05 * sin(sine*4))*angles(0,0,0),deltaTime) 
--MW_animatorProgressSave: Torso,0,0,0,1,-90,0,0,1,0,0,0,1,-0,0,0,1,0,0,0,1,180,0,0,1,MeshPartAccessory_Handle,-0.000867009162902832,0,0,1,180,0,0,1,0.6538610458374023,0,0,1,0,0,0,1,0.024028420448303223,0,0,1,180,0,0,1,LeftArm,0,0.22,60,4,180,10,0,4,-0.5,0,0,4,0,0,0,4,0,0.32,0,4,180,10,60,4,Unloadedhead_Handle,0.000171661376953125,0,0,1,180,0,0,1,0.5999884605407715,0,0,1,0,0,0,1,0.0004730224609375,0,0,1,180,0,0,1,RightArm,0,0.55,60,4,180,10,0,4,1.35,0,0,4,0,0,0,4,0,0.64,0,4,180,10,60,4,Head,0,0,0,1,-90,0,0,1,1,0,0,1,-0,0,0,1,0,0,0,1,180,0,0,1,RightLeg,-0.5,0,0,4,0,0,0,4,-1.24,0,0,4,0,0,0,4,0,0.05,0,4,0,0,0,4,MeshPartAccessory_Handle,0.0003427176852710545,0,0,1,-0,0,0,1,0.593110203742981,0,0,1,0,0,0,1,0.0003814697265625,0,0,1,-0,0,0,1,LeftLeg,0.5,0,0,4,-0,0,0,4,-1.24,0,0,4,0,0,0,4,0,0.05,0,4,0,0,0,4,MeshPartAccessory_Handle,0.0003427176852710545,0,0,1,-0,0,0,1,0.593110203742981,0,0,1,0,0,0,1,0.0003814697265625,0,0,1,-0,0,0,1
		end,
		fall = function()
			local Vfw, Vrt = velbycfrvec()
 
			local Cfw, Crt = velchgbycfrvec()
 
RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
--Neck.C0=Neck.C0:Lerp(cf(0,1,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
LeftShoulder.C0=LeftShoulder.C0:Lerp(cf(0.22 * sin((sine+60)*4),-0.5,0.32 * sin(sine*4))*angles(3.141592653589793+0.17453292519943295*sin(sine*4),0,3.141592653589793+0.17453292519943295*sin((sine+60)*4)),deltaTime) 
RightShoulder.C0=RightShoulder.C0:Lerp(cf(0.55 * sin((sine+60)*4),1.35,0.64 * sin(sine*4))*angles(3.141592653589793+0.17453292519943295*sin(sine*4),0,3.141592653589793+0.17453292519943295*sin((sine+60)*4)),deltaTime) 
RightHip.C0=RightHip.C0:Lerp(cf(-0.5,-1.24,0.05 * sin(sine*4))*angles(0,0,0),deltaTime) 
LeftHip.C0=LeftHip.C0:Lerp(cf(0.5,-1.24,0.05 * sin(sine*4))*angles(0,0,0),deltaTime) 
--MW_animatorProgressSave: Torso,0,0,0,1,-90,0,0,1,0,0,0,1,-0,0,0,1,0,0,0,1,180,0,0,1,MeshPartAccessory_Handle,-0.000867009162902832,0,0,1,180,0,0,1,0.6538610458374023,0,0,1,0,0,0,1,0.024028420448303223,0,0,1,180,0,0,1,LeftArm,0,0.22,60,4,180,10,0,4,-0.5,0,0,4,0,0,0,4,0,0.32,0,4,180,10,60,4,Unloadedhead_Handle,0.000171661376953125,0,0,1,180,0,0,1,0.5999884605407715,0,0,1,0,0,0,1,0.0004730224609375,0,0,1,180,0,0,1,RightArm,0,0.55,60,4,180,10,0,4,1.35,0,0,4,0,0,0,4,0,0.64,0,4,180,10,60,4,Head,0,0,0,1,-90,0,0,1,1,0,0,1,-0,0,0,1,0,0,0,1,180,0,0,1,RightLeg,-0.5,0,0,4,0,0,0,4,-1.24,0,0,4,0,0,0,4,0,0.05,0,4,0,0,0,4,MeshPartAccessory_Handle,0.0003427176852710545,0,0,1,-0,0,0,1,0.593110203742981,0,0,1,0,0,0,1,0.0003814697265625,0,0,1,-0,0,0,1,LeftLeg,0.5,0,0,4,-0,0,0,4,-1.24,0,0,4,0,0,0,4,0,0.05,0,4,0,0,0,4,MeshPartAccessory_Handle,0.0003427176852710545,0,0,1,-0,0,0,1,0.593110203742981,0,0,1,0,0,0,1,0.0003814697265625,0,0,1,-0,0,0,1
		end
	})
 
	addmode("q", {
		idle = function()
			local Cfw, Crt = velchgbycfrvec()
RightHip.C0=RightHip.C0:Lerp(cf(-0.5,0,3+1*sin(sine*16))*angles(0,0,0),deltaTime) 
RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,0)*angles(0,0,3.141592653589793),deltaTime) 
LeftShoulder.C0=LeftShoulder.C0:Lerp(cf(0,-0.5,1+1*sin(sine*16))*angles(1.5707963267948966,0,3.141592653589793),deltaTime) 
LeftHip.C0=LeftHip.C0:Lerp(cf(0.5,0,3+1*sin(sine*16))*angles(0,0,0),deltaTime) 
RightShoulder.C0=RightShoulder.C0:Lerp(cf(0,-0.5,-0.85+1*sin(sine*16))*angles(1.5707963267948966,0,3.141592653589793),deltaTime) 
			end
	})
 
	addmode("e", {
		idle = function()
			local Cfw, Crt = velchgbycfrvec()
 
RightHip.C0=RightHip.C0:Lerp(cf(-0.5,0,3+1*sin(sine*16))*angles(0,0,0),deltaTime) 
RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
LeftShoulder.C0=LeftShoulder.C0:Lerp(cf(0,-0.5,1+1*sin(sine*16))*angles(1.5707963267948966,0,3.141592653589793),deltaTime) 
LeftHip.C0=LeftHip.C0:Lerp(cf(0.5,0,3+1*sin(sine*16))*angles(0,0,0),deltaTime) 
RightShoulder.C0=RightShoulder.C0:Lerp(cf(0,-0.5,-0.85+1*sin(sine*16))*angles(1.5707963267948966,0,3.141592653589793),deltaTime) 
--Neck.C0=Neck.C0:Lerp(cf(0,1,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
--MW_animatorProgressSave: RightLeg,-0.5,0,0,16,0,0,0,16,0,0,0,16,0,0,0,16,3,1,0,16,0,0,0,16,MeshPartAccessory_Handle,0.0003427176852710545,0,0,4,-0,0,0,4,0.593110203742981,0,0,4,0,0,0,4,0.0003814697265625,0,0,4,-0,0,0,4,Torso,0,0,0,4,-90,0,0,4,0,0,0,4,-0,0,0,4,0,0,0,4,180,0,0,4,LeftArm,0,0,0,16,90,0,0,16,-0.5,0,0,16,0,0,0,16,1,1,0,16,180,0,0,16,LeftLeg,0.5,0,0,16,-0,0,0,16,0,0,0,16,0,0,0,16,3,1,0,16,0,0,0,16,MeshPartAccessory_Handle,0.0003427176852710545,0,0,4,-0,0,0,4,0.593110203742981,0,0,4,0,0,0,4,0.0003814697265625,0,0,4,-0,0,0,4,RightArm,0,0,0,16,90,0,0,16,-0.5,0,0,16,0,0,0,16,-0.85,1,0,16,180,0,0,16,Head,0,0,0,4,-90,0,0,4,1,0,0,4,-0,0,0,4,0,0,0,4,180,0,0,4
 
		end,
		walk = function()
			local Cfw, Crt = velchgbycfrvec()
RightHip.C0=RightHip.C0:Lerp(cf(-0.5,0,3+1*sin(sine*16))*angles(0,0,0),deltaTime) 
RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
LeftShoulder.C0=LeftShoulder.C0:Lerp(cf(0,-0.5,1+1*sin(sine*16))*angles(1.5707963267948966,0,3.141592653589793),deltaTime) 
LeftHip.C0=LeftHip.C0:Lerp(cf(0.5,0,3+1*sin(sine*16))*angles(0,0,0),deltaTime) 
RightShoulder.C0=RightShoulder.C0:Lerp(cf(0,-0.5,-0.85+1*sin(sine*16))*angles(1.5707963267948966,0,3.141592653589793),deltaTime) 
--Neck.C0=Neck.C0:Lerp(cf(0,1,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
--MW_animatorProgressSave: RightLeg,-0.5,0,0,16,0,0,0,16,0,0,0,16,0,0,0,16,3,1,0,16,0,0,0,16,MeshPartAccessory_Handle,0.0003427176852710545,0,0,4,-0,0,0,4,0.593110203742981,0,0,4,0,0,0,4,0.0003814697265625,0,0,4,-0,0,0,4,Torso,0,0,0,4,-90,0,0,4,0,0,0,4,-0,0,0,4,0,0,0,4,180,0,0,4,LeftArm,0,0,0,16,90,0,0,16,-0.5,0,0,16,0,0,0,16,1,1,0,16,180,0,0,16,LeftLeg,0.5,0,0,16,-0,0,0,16,0,0,0,16,0,0,0,16,3,1,0,16,0,0,0,16,MeshPartAccessory_Handle,0.0003427176852710545,0,0,4,-0,0,0,4,0.593110203742981,0,0,4,0,0,0,4,0.0003814697265625,0,0,4,-0,0,0,4,RightArm,0,0,0,16,90,0,0,16,-0.5,0,0,16,0,0,0,16,-0.85,1,0,16,180,0,0,16,Head,0,0,0,4,-90,0,0,4,1,0,0,4,-0,0,0,4,0,0,0,4,180,0,0,4
 
end,
		jump = function()
			local Vfw, Vrt = velbycfrvec()
 
			local Cfw, Crt = velchgbycfrvec()
 
RightHip.C0=RightHip.C0:Lerp(cf(-0.5,0,3+1*sin(sine*16))*angles(0,0,0),deltaTime) 
RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
LeftShoulder.C0=LeftShoulder.C0:Lerp(cf(0,-0.5,1+1*sin(sine*16))*angles(1.5707963267948966,0,3.141592653589793),deltaTime) 
LeftHip.C0=LeftHip.C0:Lerp(cf(0.5,0,3+1*sin(sine*16))*angles(0,0,0),deltaTime) 
RightShoulder.C0=RightShoulder.C0:Lerp(cf(0,-0.5,-0.85+1*sin(sine*16))*angles(1.5707963267948966,0,3.141592653589793),deltaTime) 
--Neck.C0=Neck.C0:Lerp(cf(0,1,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
--MW_animatorProgressSave: RightLeg,-0.5,0,0,16,0,0,0,16,0,0,0,16,0,0,0,16,3,1,0,16,0,0,0,16,MeshPartAccessory_Handle,0.0003427176852710545,0,0,4,-0,0,0,4,0.593110203742981,0,0,4,0,0,0,4,0.0003814697265625,0,0,4,-0,0,0,4,Torso,0,0,0,4,-90,0,0,4,0,0,0,4,-0,0,0,4,0,0,0,4,180,0,0,4,LeftArm,0,0,0,16,90,0,0,16,-0.5,0,0,16,0,0,0,16,1,1,0,16,180,0,0,16,LeftLeg,0.5,0,0,16,-0,0,0,16,0,0,0,16,0,0,0,16,3,1,0,16,0,0,0,16,MeshPartAccessory_Handle,0.0003427176852710545,0,0,4,-0,0,0,4,0.593110203742981,0,0,4,0,0,0,4,0.0003814697265625,0,0,4,-0,0,0,4,RightArm,0,0,0,16,90,0,0,16,-0.5,0,0,16,0,0,0,16,-0.85,1,0,16,180,0,0,16,Head,0,0,0,4,-90,0,0,4,1,0,0,4,-0,0,0,4,0,0,0,4,180,0,0,4
		end,
		fall = function()
			local Vfw, Vrt = velbycfrvec()
 
			local Cfw, Crt = velchgbycfrvec()
 
RightHip.C0=RightHip.C0:Lerp(cf(-0.5,0,3+1*sin(sine*16))*angles(0,0,0),deltaTime) 
RootJoint.C0=RootJoint.C0:Lerp(cf(0,0,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
LeftShoulder.C0=LeftShoulder.C0:Lerp(cf(0,-0.5,1+1*sin(sine*16))*angles(1.5707963267948966,0,3.141592653589793),deltaTime) 
LeftHip.C0=LeftHip.C0:Lerp(cf(0.5,0,3+1*sin(sine*16))*angles(0,0,0),deltaTime) 
RightShoulder.C0=RightShoulder.C0:Lerp(cf(0,-0.5,-0.85+1*sin(sine*16))*angles(1.5707963267948966,0,3.141592653589793),deltaTime) 
--Neck.C0=Neck.C0:Lerp(cf(0,1,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
--MW_animatorProgressSave: RightLeg,-0.5,0,0,16,0,0,0,16,0,0,0,16,0,0,0,16,3,1,0,16,0,0,0,16,MeshPartAccessory_Handle,0.0003427176852710545,0,0,4,-0,0,0,4,0.593110203742981,0,0,4,0,0,0,4,0.0003814697265625,0,0,4,-0,0,0,4,Torso,0,0,0,4,-90,0,0,4,0,0,0,4,-0,0,0,4,0,0,0,4,180,0,0,4,LeftArm,0,0,0,16,90,0,0,16,-0.5,0,0,16,0,0,0,16,1,1,0,16,180,0,0,16,LeftLeg,0.5,0,0,16,-0,0,0,16,0,0,0,16,0,0,0,16,3,1,0,16,0,0,0,16,MeshPartAccessory_Handle,0.0003427176852710545,0,0,4,-0,0,0,4,0.593110203742981,0,0,4,0,0,0,4,0.0003814697265625,0,0,4,-0,0,0,4,RightArm,0,0,0,16,90,0,0,16,-0.5,0,0,16,0,0,0,16,-0.85,1,0,16,180,0,0,16,Head,0,0,0,4,-90,0,0,4,1,0,0,4,-0,0,0,4,0,0,0,4,180,0,0,4
		end
	})
